<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lmm.cool","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="JAVA数据结构与算法 数据结构+算法&#x3D;程序">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA数据结构与算法">
<meta property="og:url" content="http://lmm.cool/2020/04/12/JAVA%E7%AE%97%E6%B3%95%E7%A7%98%E7%B1%8D/index.html">
<meta property="og:site_name" content="披着代码的🐏">
<meta property="og:description" content="JAVA数据结构与算法 数据结构+算法&#x3D;程序">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-04-12T05:07:40.000Z">
<meta property="article:modified_time" content="2020-04-17T12:36:43.670Z">
<meta property="article:author" content="yong">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://lmm.cool/2020/04/12/JAVA%E7%AE%97%E6%B3%95%E7%A7%98%E7%B1%8D/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JAVA数据结构与算法 | 披着代码的🐏</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">披着代码的🐏</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Welcome to 我的小站</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/Herface" class="github-corner" title="Fork me on GitHub" aria-label="Fork me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lmm.cool/2020/04/12/JAVA%E7%AE%97%E6%B3%95%E7%A7%98%E7%B1%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="yong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="披着代码的🐏">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JAVA数据结构与算法
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-12 13:07:40" itemprop="dateCreated datePublished" datetime="2020-04-12T13:07:40+08:00">2020-04-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="JAVA数据结构与算法"><a href="#JAVA数据结构与算法" class="headerlink" title="JAVA数据结构与算法"></a>JAVA数据结构与算法</h1><blockquote>
<p>数据结构+算法=程序</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>数据结构与算法相辅相成 不可分割</p>
<p>数据结构依赖于算法实现</p>
<p>算法能真实反应反应一个人的编程水平 而不是api的调用水平</p>
<p>算法能反应程序的性能</p>
<p>算法服务于数据结构 优秀的算法课提高数据据结构的性能</p>
<p>对于特定问题 需要使用特定的算法</p>
</blockquote>
<h2 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1 数据结构"></a>1 数据结构</h2><blockquote>
<p>数据结构是研究 是计算机存储、组织数据的方式 </p>
<p>主要分为两大类</p>
<ul>
<li><p>线性结构</p>
<p>数据元素之间存在一对一的线性关系</p>
<p>线性结构又分为 顺序表和链表</p>
<p>顺序表的元素在内存的地址是连续的 链表是不连续的</p>
<p>线性结构常见的有 数组 队列 链表 栈</p>
</li>
<li><p>非线性结构</p>
<p>主要包含： 二维数组 多维数组 广义表 树 图</p>
</li>
</ul>
</blockquote>
<h3 id="1-1-线性结构"><a href="#1-1-线性结构" class="headerlink" title="1.1 线性结构"></a>1.1 线性结构</h3><h4 id="1-1-1-稀疏数组"><a href="#1-1-1-稀疏数组" class="headerlink" title="1.1.1 稀疏数组"></a>1.1.1 稀疏数组</h4><blockquote>
<p>当数组中大部分元素为0时 或者为同一个值时 可以使用稀疏数组对其进行压缩以节省空间</p>
</blockquote>
<ul>
<li><p>处理方案</p>
<ul>
<li>记录数组有几行或几列 有多少相同的值</li>
<li>把具有不同值得元素得行列及值记录在一个小规模的数组中 从而缩小规模 如 n<em>n 的二维数组 可以转化为 3\</em>n的二维数组(记录 行 列 值)</li>
</ul>
</li>
<li><p>基本思路</p>
<ol>
<li>遍历计算二维数组中有效值的个数n</li>
<li>创建(n+1)*3的稀疏数组 第一行存储原二维数组的行列 有效值个数信息</li>
<li>再次遍历二维数组将有效值存入稀疏数组</li>
</ol>
</li>
<li><p>demo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 稀疏</span></span><br><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">arr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">arr[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">arr[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> row = arr.length;</span><br><span class="line"><span class="keyword">int</span> col = arr[<span class="number">0</span>].length;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span>[] i : arr) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j : i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j!=<span class="number">0</span>) &#123;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span>[][] sparseArr = <span class="keyword">new</span> <span class="keyword">int</span>[sum+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line"><span class="comment">// 第一行存行 列 有效元素个数</span></span><br><span class="line">sparseArr[<span class="number">0</span>][<span class="number">0</span>] = row;</span><br><span class="line">sparseArr[<span class="number">0</span>][<span class="number">1</span>] = col;</span><br><span class="line">sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i][j]!=<span class="number">0</span>) &#123;</span><br><span class="line">            sparseArr[count][<span class="number">0</span>] = i; </span><br><span class="line">            sparseArr[count][<span class="number">1</span>] = j;</span><br><span class="line">            sparseArr[count][<span class="number">2</span>] = arr[i][j];</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数组还原</span></span><br><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">    arr[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]] = sparseArr[i][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="1-1-2-队列"><a href="#1-1-2-队列" class="headerlink" title="1.1.2 队列"></a>1.1.2 队列</h4><blockquote>
<p>队列是一种有序列表 可用数组或链表实现</p>
<p>遵循先入先出的原则</p>
<p>需要一个队头front和队尾rear指针 初始值为-1</p>
</blockquote>
<ul>
<li><p>数组实现</p>
<ul>
<li><p>思路</p>
<ol>
<li>入队时rear+1 出队时fonrt+1</li>
<li>当rear = capacity -1 时 队列满</li>
<li>当rear=front 队列空</li>
<li>初始rear=front=-1</li>
<li>环形数组优化: <ul>
<li>front指向第一个节点</li>
<li>rear指向最后一个节点的后一位置 空出一个空间作为约定</li>
<li>当队列满时 <strong>(rear+1)%maxSize == front</strong></li>
<li>rear == front 队列空</li>
<li>初始front=rear=0</li>
<li>队列中的有效元素个数<strong>(rear+maxSize-front)%maxSize</strong></li>
</ul>
</li>
</ol>
</li>
<li><p>demo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">	<span class="comment">// 头节点</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">	<span class="comment">//尾节点</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> rear;</span><br><span class="line">	<span class="comment">// 数组</span></span><br><span class="line">	<span class="keyword">private</span> Node&lt;E&gt;[] arr;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(<span class="number">17</span>);</span><br><span class="line">		<span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">		arr = <span class="keyword">new</span> Node[maxSize];</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 入队</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enQeueue</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(isFull()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;&gt;(e);</span><br><span class="line">		arr[rear] = node;</span><br><span class="line">		rear = (rear+<span class="number">1</span>) % maxSize;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 出队</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> E <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(isEmpty()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		</span><br><span class="line">		E e = arr[front].item;</span><br><span class="line">		front = (front+<span class="number">1</span>)%maxSize;</span><br><span class="line">		<span class="keyword">return</span> e;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (rear+<span class="number">1</span>)%maxSize==front;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (rear+maxSize-front) % maxSize;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> rear == front;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">			E item;</span><br><span class="line">			Node(E e)&#123;</span><br><span class="line">				item =e;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		</span><br><span class="line">		StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		</span><br><span class="line">		builder.append(<span class="string">"[ "</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = front; i &lt; front+size(); i++) &#123;</span><br><span class="line">		 	builder.append(arr[i % maxSize].item+<span class="string">", "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		builder.append(<span class="string">"]"</span>);</span><br><span class="line">		<span class="keyword">return</span> builder.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="1-1-3-链表"><a href="#1-1-3-链表" class="headerlink" title="1.1.3 链表"></a>1.1.3 链表</h4><blockquote>
<p>有序列表  每个元素称为节点 每个节点包含数据域(data)和下一节点的引用(next)</p>
<p>在内存空间中地址不一定连续</p>
<p>分为有头节点 和无头节点</p>
</blockquote>
<h5 id="1-1-3-1-单向链表"><a href="#1-1-3-1-单向链表" class="headerlink" title="1.1.3.1 单向链表"></a>1.1.3.1 单向链表</h5><blockquote>
<p>节点之间单向连接 只能单向查找</p>
<p>节点无法自我删除 必须先找到前一个节点作为辅助</p>
</blockquote>
<h5 id="1-1-3-2-双向链表"><a href="#1-1-3-2-双向链表" class="headerlink" title="1.1.3.2 双向链表"></a>1.1.3.2 双向链表</h5><blockquote>
<p>节点之间双向连接 每个节点含有前一节点和后一节点的引用</p>
<p>支持双向查找</p>
</blockquote>
<ul>
<li><p>带顺序插入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;&gt;(e, score);</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>) &#123;</span><br><span class="line">        head = node;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur.next!=<span class="keyword">null</span> &amp;&amp; cur.next.score&lt;score) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur.next==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur==head) &#123;</span><br><span class="line">                <span class="keyword">if</span>(head.score&gt;score) &#123;</span><br><span class="line">                    node.next = head;</span><br><span class="line">                    head.prev = node;</span><br><span class="line">                    head =node;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    node.prev = head;</span><br><span class="line">                    head.next = node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev = cur;</span><br><span class="line">                cur.next =node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur==head) &#123;</span><br><span class="line">                <span class="keyword">if</span>(head.score&gt;score) &#123;</span><br><span class="line">                    node.next = head;</span><br><span class="line">                    head.prev = node;</span><br><span class="line">                    head = node;</span><br><span class="line">                    size++;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            cur.prev.next = node;</span><br><span class="line">            node.next = cur;</span><br><span class="line">            node.prev = cur.prev;</span><br><span class="line">            cur.prev = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h5 id="1-1-3-3-循环链表"><a href="#1-1-3-3-循环链表" class="headerlink" title="1.1.3.3 循环链表"></a>1.1.3.3 循环链表</h5><blockquote>
<p>头节点与尾节点相连就形成了循环链表</p>
</blockquote>
<h4 id="1-1-4-链表面试题"><a href="#1-1-4-链表面试题" class="headerlink" title="1.1.4 链表面试题"></a>1.1.4 链表面试题</h4><h5 id="1-1-4-1-求链表倒数第k个节点"><a href="#1-1-4-1-求链表倒数第k个节点" class="headerlink" title="1.1.4.1 求链表倒数第k个节点"></a>1.1.4.1 求链表倒数第k个节点</h5><ul>
<li><p>思路</p>
<ol>
<li>先得到链表总长度length</li>
<li>算出倒序索引k的正序索引 index (length-k)</li>
<li>从头遍历到index</li>
</ol>
</li>
<li><p>demo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">rget</span><span class="params">(<span class="keyword">int</span> rindex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = size - rindex;</span><br><span class="line">    <span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;size) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;E&gt; cur = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; index; i++) &#123;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur.item;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="1-1-4-2-反转链表"><a href="#1-1-4-2-反转链表" class="headerlink" title="1.1.4.2 反转链表"></a>1.1.4.2 反转链表</h5><ul>
<li><p>思路</p>
<ol>
<li>定义一个节点reversedHead</li>
<li>从头到尾遍历原来的列表 每遍历一个节点 就将其取出 并插入到链表reversed的最前端</li>
<li>原来的head.next=reversedHead.next</li>
</ol>
</li>
<li><p>demo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty() || size==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    Node&lt;E&gt; cur = head;</span><br><span class="line">    head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="keyword">null</span>) &#123;</span><br><span class="line">       </span><br><span class="line">        insert(cur.item, <span class="number">0</span>);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="1-1-4-3-逆序打印链表"><a href="#1-1-4-3-逆序打印链表" class="headerlink" title="1.1.4.3 逆序打印链表"></a>1.1.4.3 逆序打印链表</h5><ul>
<li>思路<ol>
<li>先反转再打印</li>
<li>利用栈结构 将各个节点压入栈中 然后遍历弹出栈  实现逆序</li>
</ol>
</li>
</ul>
<h5 id="1-1-4-4-合并两个有序单链表"><a href="#1-1-4-4-合并两个有序单链表" class="headerlink" title="1.1.4.4 合并两个有序单链表"></a>1.1.4.4 合并两个有序单链表</h5><ul>
<li>思路<ol>
<li>将两个链表依次遍历 按排序规则添加到一个新的链表</li>
</ol>
</li>
</ul>
<h5 id="1-1-4-5-约瑟夫环"><a href="#1-1-4-5-约瑟夫环" class="headerlink" title="1.1.4.5 约瑟夫环"></a>1.1.4.5 约瑟夫环</h5><blockquote>
<p>n个人围坐一圈  设定编号为k(1&lt;=k&lt;=n)的人开始报数 数到m的那个人出列  下一位又从1开始报数 以此类推 直到所有人出列为止</p>
</blockquote>
<ul>
<li><p>思路</p>
<ol>
<li><p>环形链表</p>
<ul>
<li><p>单向链表</p>
<p>需要一个辅助变量 指向当前节点的一个节点</p>
</li>
<li><p>双向链表</p>
<p>无需辅助接点</p>
</li>
</ul>
</li>
<li><p>数组取模</p>
<p>通过对数组下标取模来模拟环形链表</p>
</li>
</ol>
</li>
<li><p>环链表版</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">josephu</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> step, @SuppressWarnings(<span class="string">"unchecked"</span>)</span> E... args) </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = args.length;</span><br><span class="line">    <span class="keyword">for</span>(E e: args) &#123;</span><br><span class="line">        add(e);	</span><br><span class="line">    &#125;</span><br><span class="line">    Node&lt;E&gt; cur = head;</span><br><span class="line">    <span class="comment">// 移动到指定位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; start; i++) &#123;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(count&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 开始报数 遍历到下一个要被删除的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; step; i++) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"========&gt;"</span>+cur.item);</span><br><span class="line">        cur.prev.next = cur.next;</span><br><span class="line">        cur.next.prev = cur.prev;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    head = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>索引取模版</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">josephu</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> step, E...args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (E e:args) &#123;</span><br><span class="line">        add(e);</span><br><span class="line">    &#125;</span><br><span class="line">    Node&lt;E&gt; cur = head;</span><br><span class="line">    start = start % size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; start; i++) &#123;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 每次计算新的链表长度</span></span><br><span class="line">        <span class="keyword">int</span> size = size();</span><br><span class="line">        <span class="comment">// 计算下一个改删除的元素索引</span></span><br><span class="line">        start = (start + step -<span class="number">1</span>) % size ;</span><br><span class="line">        E e = delete(start);</span><br><span class="line">        System.out.println(<span class="string">"==========&gt;"</span>+e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h4 id="1-1-5-栈"><a href="#1-1-5-栈" class="headerlink" title="1.1.5 栈"></a>1.1.5 栈</h4><blockquote>
<p>栈(stack) 是一种先入后出(FILO)的有序列表</p>
<p>只能在一端操作数据 变化的一段称为栈顶 不变的一端称为栈底 有出栈(pop)和入栈(push)两种操作</p>
<p>应用:</p>
<ul>
<li>子程序的调用 跳往子程序前 将下一个指令存于堆栈 直到返子程序执行完毕后取出 继续执行</li>
<li>递归调用 除了存储下一个地址之外 也将参数 局部变量加入其中</li>
<li>表达式转换</li>
<li>二叉树的遍历</li>
<li>图的深度优先搜索</li>
</ul>
</blockquote>
<ul>
<li><p>数组实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top == maxSize-<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    value[++top] = e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) value[top--];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>链表实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;&gt;(e);</span><br><span class="line">    node.next = head;</span><br><span class="line">    head = node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    E e = head.item;</span><br><span class="line">    head = head.next;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="1-1-5-1-栈实现综合计算器-中缀表达式"><a href="#1-1-5-1-栈实现综合计算器-中缀表达式" class="headerlink" title="1.1.5.1 栈实现综合计算器 (中缀表达式)"></a>1.1.5.1 栈实现综合计算器 (中缀表达式)</h5><blockquote>
<p>通过栈实现一连串的数学表达式计算</p>
<p>中缀表达式 操作符位于操作数之间</p>
</blockquote>
<ul>
<li><p>思路</p>
<ol>
<li>通过索引 遍历表达式</li>
<li>如果是数字 放入操作数栈 如果是操作符 放入操作符栈</li>
<li>如果操作符栈为空直接入栈 如果不为空 需要与栈顶的操作符进行比较 如果当前操作符优先级小于或等于栈顶的操作符 需要将操作数栈中弹出两个数 从操作符栈顶中弹出一个符号进行运算 并将结果放回操作数栈 然后将当前操作符入栈 如果当前操作符优先级大于栈顶的操作符 直接入操作符栈</li>
<li>当表达式扫描完毕时 按顺序从操作数栈和符号栈取出数和符号 并计算后结果压入栈 最后在数栈中仅存的数字即为运算结果</li>
<li>优化:<ul>
<li>处理多位数时 需要再往后扫描 直到扫描到符号时才入栈</li>
</ul>
</li>
</ol>
</li>
<li><p>demo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">SingleLinkedList&lt;Integer&gt; numStack = <span class="keyword">new</span> SingleLinkedList&lt;&gt;();</span><br><span class="line">SingleLinkedList&lt;String&gt; opStack = <span class="keyword">new</span> SingleLinkedList&lt;&gt;();</span><br><span class="line">String[] nums = expression.split(<span class="string">"[\\+\\-\\*/]"</span>);</span><br><span class="line">String[] ops = expression.split(<span class="string">"\\d+"</span>);</span><br><span class="line">ops = Arrays.copyOfRange(ops, <span class="number">1</span>, ops.length);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = Integer.parseInt(nums[i]);</span><br><span class="line">        String op = ops[i];</span><br><span class="line">        numStack.push(num);</span><br><span class="line">        <span class="keyword">if</span> (opStack.isEmpty()) &#123;</span><br><span class="line">            opStack.push(op);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String topOp = opStack.peek();</span><br><span class="line">            <span class="keyword">if</span> (priority(op) &lt;= priority(topOp)) &#123;</span><br><span class="line">                <span class="keyword">int</span> num1 = numStack.pop();</span><br><span class="line">                <span class="keyword">int</span> num2 = numStack.pop();</span><br><span class="line">                topOp = opStack.pop();</span><br><span class="line">                <span class="keyword">int</span> result = result(num1, num2, topOp);</span><br><span class="line">                numStack.push(result);</span><br><span class="line">                opStack.push(op);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                opStack.push(op);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将最后一个数入栈 操作数数量=操作符数量+1</span></span><br><span class="line">        numStack.push(Integer.parseInt(nums[i]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!opStack.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> num1 = numStack.pop();</span><br><span class="line">    <span class="keyword">int</span> num2 = numStack.pop();</span><br><span class="line">    String op = opStack.pop();</span><br><span class="line">    <span class="keyword">int</span> result = result(num1, num2, op);</span><br><span class="line">    numStack.push(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> numStack.pop();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="1-1-5-2-计算器-前缀表达式"><a href="#1-1-5-2-计算器-前缀表达式" class="headerlink" title="1.1.5.2 计算器(前缀表达式)"></a>1.1.5.2 计算器(前缀表达式)</h5><blockquote>
<p>前缀表达式(又称波兰式) 运算符位于操作数之前 </p>
<p><strong>运算符顺序倒转</strong></p>
<p>可解决小括号优先级问题</p>
<p><strong>流程:</strong> 从右至左扫描表达式 遇到数字时 弹出栈顶的两个数 用运算符对它们做相应的运算(栈顶元素和次顶元素) 并将结果压入栈 重复上述过程直到表达式最左端 最后运算得出的值即为表达式的结果</p>
</blockquote>
<h5 id="1-1-5-3-后缀表达式"><a href="#1-1-5-3-后缀表达式" class="headerlink" title="1.1.5.3  后缀表达式"></a>1.1.5.3  后缀表达式</h5><blockquote>
<p>又称逆波兰式 运算符位于两个操作数之后</p>
<p><strong>流程:</strong> 从左至右扫描表达式 遇到数字时 将数压入栈 遇到运算符时 弹出栈顶的两个数 用运算符进行运算(次顶元素和栈顶元素) 并将结果压入栈 重复上述过程直到表达式最右端 最后运算得出的值即为表达式的结果</p>
</blockquote>
<ul>
<li><p>逆波兰计算器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; infix = expressionToList(expression);  <span class="comment">// 字符串转列表</span></span><br><span class="line">List&lt;String&gt; suffix = infixToSuffix(infix); <span class="comment">// 中缀转后缀</span></span><br><span class="line">SingleLinkedList&lt;String&gt; stack = <span class="keyword">new</span> SingleLinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(String s : suffix) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.matches(<span class="string">"\\d+"</span>)) &#123;</span><br><span class="line">        stack.push(s);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> num2 = Integer.parseInt(stack.pop());</span><br><span class="line">        <span class="keyword">int</span> num1 = Integer.parseInt(stack.pop());</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span>(s) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">                result = num1+ num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">                result = num1 - num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">                result = num1 * num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">                result = num1 / num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(result+<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br></pre></td></tr></table></figure>
</li>
<li><p>中缀转后缀</p>
<ol>
<li><p>初始化两个栈 运算符栈s1与存储中间结果栈s2</p>
</li>
<li><p>从左至右扫描表达式</p>
</li>
<li><p>遇到操作数时 将其压入s2</p>
</li>
<li><p>遇到运算符  比较其与s1栈顶运算符的优先级</p>
<ol>
<li><p>如果s1为空 或栈顶符号为 ( 则直接将此运算符入栈）</p>
</li>
<li><p>否则 若优先级比栈顶优先级高 也将运算符压入s1</p>
</li>
<li><p>否则 将s1栈顶的运算符弹出并压入s2中 再次转到4.1与s1中新的栈顶运算符相比较 直到遇到优先级低的才入栈</p>
</li>
</ol>
</li>
<li><p>遇到括号时</p>
<ul>
<li>如果是 (  则直接压入s1</li>
<li>如果是 )  则依次弹出s1栈顶的运算符 并压入s2 直到遇到 ( 为止 此时将这一对括号丢弃</li>
</ul>
</li>
<li><p>重复步骤2至5 直到表达式的最右边</p>
</li>
<li><p>将s1中剩余的运算符一次弹出并压入s2</p>
</li>
<li><p>依次弹出s2 结果的逆序即为中缀表达式的后缀表达式</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;String&gt; <span class="title">infixToSuffix</span><span class="params">(List&lt;String&gt; expLs)</span></span>&#123;</span><br><span class="line">    SingleLinkedList&lt;String&gt; s1 = <span class="keyword">new</span> SingleLinkedList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; s2 = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 可用列表模拟栈 s2只有添加操作</span></span><br><span class="line">    <span class="keyword">for</span> (String item : expLs) &#123;</span><br><span class="line">        <span class="comment">// 数字直接入s2</span></span><br><span class="line">        <span class="keyword">if</span>(item.charAt(<span class="number">0</span>) &gt;=<span class="number">48</span> &amp;&amp; item.charAt(<span class="number">0</span>) &lt;=<span class="number">57</span>) &#123;</span><br><span class="line">            s2.add(item);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// s1 为空 或栈顶为( 或 操作符为( 直接入栈</span></span><br><span class="line">            <span class="keyword">if</span>(s1.isEmpty() || <span class="string">"("</span>.equals(s1.peek()) || <span class="string">"("</span>.equals(item)) &#123;</span><br><span class="line">                s1.push(item);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">")"</span>.equals(item)) &#123;</span><br><span class="line">                <span class="keyword">while</span>(!<span class="string">"("</span>.equals(s1.peek())) &#123;</span><br><span class="line">                    s2.add(s1.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                s1.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 转移所有优先级大于当前操作符的操作符</span></span><br><span class="line">                <span class="keyword">while</span>(!s1.isEmpty() &amp;&amp; priority(s1.peek())&gt;=priority(item)) &#123;</span><br><span class="line">                    s2.add(s1.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                s1.push(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!s1.isEmpty()) &#123;</span><br><span class="line">        s2.add(s1.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="1-2-哈希表"><a href="#1-2-哈希表" class="headerlink" title="1.2 哈希表"></a>1.2 哈希表</h3><blockquote>
<p>通过键值对查找数据 通过散列算法计算出数据的存放索引</p>
<p>常见搭配:</p>
<p>数组+链表</p>
<p>数组+树</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTab</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;K, V&gt;[] elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashTab</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashTab</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        elements = <span class="keyword">new</span> Node[size];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key.hashCode() &amp; size-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = hash(key);</span><br><span class="line">        <span class="keyword">if</span>(elements[index]!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            Node&lt;K, V&gt; node = elements[index];</span><br><span class="line">            <span class="keyword">if</span>(node.key.hashCode() == key.hashCode()) &#123;</span><br><span class="line">                V v = node.value;</span><br><span class="line">                elements[index] = node.next;</span><br><span class="line">                <span class="keyword">return</span> v;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(node.next!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(node.next.key.hashCode()==key.hashCode()) &#123;</span><br><span class="line">                        V value = node.next.value;</span><br><span class="line">                        node.next = node.next.next;</span><br><span class="line">                        <span class="keyword">return</span> value;</span><br><span class="line">                    &#125;</span><br><span class="line">                    node = node.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        builder.append(<span class="string">"&#123;"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elements.length; i++) &#123;</span><br><span class="line">            Node&lt;K, V&gt; node = elements[i];</span><br><span class="line">            <span class="keyword">if</span>(node!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span>(node!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                    builder.append(node.key+<span class="string">"="</span>+node.value+<span class="string">", "</span>);</span><br><span class="line">                    node = node.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        builder.append(<span class="string">"&#125;"</span>);</span><br><span class="line">        <span class="keyword">return</span>  builder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = hash(key);</span><br><span class="line">        <span class="keyword">if</span>(elements[index]==<span class="keyword">null</span>) &#123;</span><br><span class="line">            elements[index] = <span class="keyword">new</span> Node&lt;&gt;(key, value);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K, V&gt; node = elements[index];</span><br><span class="line">            <span class="keyword">if</span>(node.key.hashCode() == key.hashCode()) &#123;</span><br><span class="line">                node.value = value;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">boolean</span> isExist = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">while</span>(node.next!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                    Node&lt;K, V&gt; cur = node.next;</span><br><span class="line">                    <span class="keyword">if</span>(cur.key.hashCode() == key.hashCode()) &#123;</span><br><span class="line">                        cur.value = value;</span><br><span class="line">                        isExist = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    node = node.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!isExist) &#123;</span><br><span class="line">                    node.next = <span class="keyword">new</span> Node&lt;&gt;(key, value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = hash(key);</span><br><span class="line">        <span class="keyword">if</span>(elements[index]!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            Node&lt;K, V&gt; cur = elements[index];</span><br><span class="line">            <span class="keyword">while</span>(cur!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(cur.key.hashCode() == key.hashCode()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> cur.value;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">        K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K, V&gt; next;</span><br><span class="line">        Node(K key, V value)&#123;</span><br><span class="line">            <span class="keyword">this</span>.key =  key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-二叉树"><a href="#1-3-二叉树" class="headerlink" title="1.3 二叉树"></a>1.3 二叉树</h3><blockquote>
<p>与链表类似 每个节点含左子节点和右子节点的引用</p>
<p>如果所有的叶子节点都在最后一层 期额节点总数为2^n -1 n为层数 则称为满二叉树</p>
<p>如果该二叉树的所有叶子节点都在·1最后一层或者倒数第二层 而且最后一层的叶子节点都在左边连续 倒数第二层的叶子节点在右边延续 则称为完全二叉树</p>
<p>常用术语：</p>
<ul>
<li>节点</li>
<li>根节点</li>
<li>父节点</li>
<li>子节点</li>
<li>叶子节点 没有子节点的节点</li>
<li>节点权重 节点值</li>
<li>路径 从根节点找到该节点的路线</li>
<li>子树</li>
<li>树的高度 最大层数</li>
<li>森林 多颗子树构成森林</li>
</ul>
</blockquote>
<h4 id="1-3-1-遍历"><a href="#1-3-1-遍历" class="headerlink" title="1.3.1 遍历"></a>1.3.1 遍历</h4><blockquote>
<p>二叉树遍历分为前序 后序 中序遍历 取决于 根节点的位置</p>
</blockquote>
<ul>
<li><p>前序遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrderPrint</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    System.out.print(node.item+<span class="string">", "</span>);</span><br><span class="line">    <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        preOrderPrint(node.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        preOrderPrint(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>中序遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">midOrderPrint</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        midOrderPrint(node.left);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(node.item+<span class="string">", "</span>);</span><br><span class="line">    <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        midOrderPrint(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后序遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrderPrint</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        postOrderPrint(node.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        postOrderPrint(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(node.item+<span class="string">", "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="1-3-2-查找"><a href="#1-3-2-查找" class="headerlink" title="1.3.2 查找"></a>1.3.2 查找</h4><ul>
<li><p>二分查找</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">search0</span><span class="params">(Node&lt;E&gt; node, E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(node.item==e) &#123;</span><br><span class="line">            <span class="keyword">return</span>  e;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(node.item.compareTo(e)&lt;<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> search0(node.right, e);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span>  search0(node.left, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>前序查找</p>
</li>
<li><p>后续查找</p>
</li>
<li><p>中序查找</p>
</li>
</ul>
<h4 id="1-3-3-删除"><a href="#1-3-3-删除" class="headerlink" title="1.3.3 删除"></a>1.3.3 删除</h4><ul>
<li><p>删除子树节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">remove</span><span class="params">(Node&lt;E&gt; node, E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node.item.compareTo(e)&lt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(node.right.item == e) &#123;</span><br><span class="line">                node.right=<span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> remove(node.right, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(node.left.item==e) &#123;</span><br><span class="line">                node.left=<span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> remove(node.left, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="1-3-4-顺序二叉树"><a href="#1-3-4-顺序二叉树" class="headerlink" title="1.3.4 顺序二叉树"></a>1.3.4 顺序二叉树</h4><blockquote>
<p>二叉树与数组可相互转换 由数组转换来的二叉树叫做 顺序二叉树</p>
<p>可用数组模拟顺序二叉树 只考虑完全二叉树</p>
<p>第n个元素的左子节点为2*n+1</p>
<p>第n个元素的右子节点为2*n+2</p>
<p>第n个元素的父节点为(n-1)/2</p>
</blockquote>
<ul>
<li><p>前序遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrderPrint</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    System.out.print(arr[i]+<span class="string">", "</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span>*i+<span class="number">1</span>&lt;arr.length) &#123;</span><br><span class="line">        preOrderPrint(<span class="number">2</span>*i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span>*i+<span class="number">2</span>&lt;arr.length) &#123;</span><br><span class="line">        preOrderPrint(<span class="number">2</span>*i+<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="1-3-5-线索化二叉树"><a href="#1-3-5-线索化二叉树" class="headerlink" title="1.3.5 线索化二叉树"></a>1.3.5 线索化二叉树</h4><blockquote>
<p>利用空指针 存放某种次序遍历下的前驱和后继节点的指针 这种指针称为线索</p>
<p>加上线的二叉链表称为线索链表 相应的二叉树称为线索二叉树</p>
<p>left节点可能指向左子树(记为0) 也可能指向前驱节点(记为1)</p>
<p>right节点可能指向右子树(0) 也可能指向后继节点(1)</p>
</blockquote>
<ul>
<li><p>线索化前序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preThreaded</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(node.left==<span class="keyword">null</span>) &#123;</span><br><span class="line">        node.leftType = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(prev!=<span class="keyword">null</span> &amp;&amp; prev.right==<span class="keyword">null</span> &amp;&amp; prev!=root) &#123;</span><br><span class="line">        prev.right = node;</span><br><span class="line">        prev.rightType = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    prev = node;	</span><br><span class="line">    preThreaded(node.left);</span><br><span class="line">    preThreaded(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>线索化中序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线索化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">midThreaded</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    midThreaded(node.left);</span><br><span class="line">    <span class="comment">// 让左子节点指向前驱节点</span></span><br><span class="line">    <span class="keyword">if</span>(node.left==<span class="keyword">null</span>) &#123;</span><br><span class="line">        node.left = prev;</span><br><span class="line">        node.leftType = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右子节点指向后继节点</span></span><br><span class="line">    <span class="keyword">if</span>(prev!=<span class="keyword">null</span> &amp;&amp; prev.right==<span class="keyword">null</span>) &#123;</span><br><span class="line">        prev.right = node;</span><br><span class="line">        prev.rightType = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    prev  = node;</span><br><span class="line">    midThreaded(node.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">midThreadedPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; node = root;</span><br><span class="line">    System.out.print(<span class="string">"[ "</span>);</span><br><span class="line">    <span class="keyword">while</span>(node!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(node.leftType==<span class="number">0</span>) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(node.item+<span class="string">", "</span>);</span><br><span class="line">        <span class="keyword">while</span>(node.rightType==<span class="number">1</span>) &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">            System.out.print(node.item+<span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.right;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>线索化后序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序线索化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrderThreaded</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    postOrderThreaded(node.left);</span><br><span class="line">    postOrderThreaded(node.right);</span><br><span class="line">    <span class="keyword">if</span>(node.left==<span class="keyword">null</span>) &#123;</span><br><span class="line">        node.leftType = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(prev!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        prev.right = node;</span><br><span class="line">        prev.rightType = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    prev = node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线索化遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrderThreadedPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; node = root;</span><br><span class="line">    System.out.print(<span class="string">"[ "</span>);</span><br><span class="line">    <span class="keyword">while</span>(node!=root.right) &#123;</span><br><span class="line">        <span class="keyword">while</span>(node.leftType==<span class="number">0</span>) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(node.item+<span class="string">", "</span>);</span><br><span class="line">        <span class="keyword">while</span>(node.rightType==<span class="number">1</span>) &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">            System.out.print(node.item+<span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.right;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(<span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h4 id="1-3-6-霍夫曼树"><a href="#1-3-6-霍夫曼树" class="headerlink" title="1.3.6 霍夫曼树"></a>1.3.6 霍夫曼树</h4><blockquote>
<p>给定n个权值作为n个节点 构造一棵二叉树 若该树得带权路径长度达到最小 则成为最优二叉树 称为Huffman Tree</p>
<p>在树中 从一个节点往下可以达到得孩子节点或孙子节点之间的通路 称为路径 乘以每个节点得权得到的结果称为带权路径(wpl)</p>
<p>数据存储在叶子节点</p>
</blockquote>
<h5 id="1-3-6-1-构建霍夫曼树"><a href="#1-3-6-1-构建霍夫曼树" class="headerlink" title="1.3.6.1 构建霍夫曼树"></a>1.3.6.1 构建霍夫曼树</h5><blockquote>
<p>将数组构建为霍夫曼树</p>
<p>基本思路</p>
<ol>
<li>从小到大进行排序 将每一个数据当时是一个节点 每个节点可当作一颗二叉树</li>
<li>取出根节点权值最小的两颗二叉树</li>
<li>组成一颗新的二叉树 将新的二叉树的根节点的权值设为前面两颗二叉树根节点权值之和</li>
<li>再将新的二叉树 以节点权值大小再次排序 不断重复 步骤1 2 3  知道数列中所有的数据都被处理</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> &lt;E extends Comparable&lt;E&gt;&gt; <span class="function">HuffmanTree&lt;E&gt; <span class="title">createHuffmanTree</span><span class="params">(E[] args, <span class="keyword">int</span>[] weights)</span> </span>&#123;</span><br><span class="line">    List&lt;Node&lt;E&gt;&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">        nodes.add(<span class="keyword">new</span> Node&lt;E&gt;(args[i], weights[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        Collections.sort(nodes);</span><br><span class="line">        Node&lt;E&gt; left = nodes.get(<span class="number">0</span>);</span><br><span class="line">        Node&lt;E&gt; right = nodes.get(<span class="number">1</span>);</span><br><span class="line">        Node&lt;E&gt; parent = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>,left.weight + right.weight);</span><br><span class="line">        parent.left = left;</span><br><span class="line">        parent.right = right;</span><br><span class="line">        nodes.remove(left);</span><br><span class="line">        nodes.remove(right);</span><br><span class="line">        nodes.add(parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HuffmanTree&lt;&gt;(nodes.get(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-7-二叉排序树"><a href="#1-3-7-二叉排序树" class="headerlink" title="1.3.7 二叉排序树"></a>1.3.7 二叉排序树</h4><blockquote>
<p>对于任何一个非子叶节点 要求左子节点的值比右子节点的值小 右子节点比当前节点的值大</p>
<p>如果有相同的值 放在左或右子节点</p>
</blockquote>
<h5 id="1-3-7-1-删除节点"><a href="#1-3-7-1-删除节点" class="headerlink" title="1.3.7.1 删除节点"></a>1.3.7.1 删除节点</h5><blockquote>
<p>分三种情况</p>
<ol>
<li>删除的节点是叶子节点</li>
<li>删除的节点含有一个叶子节点</li>
<li>删除的节点有两个子树节点<ul>
<li>先找到目标节点targetNode</li>
<li>再找到父节点parent</li>
<li>从targetNode的右子树找到最小的节点 temp (最左叶子节点) 或从左子树找到最大叶子节点(最右叶子节点)</li>
<li>删除temp</li>
<li>targetNode.value = temp</li>
</ul>
</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">remove</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;	</span><br><span class="line">    Node&lt;E&gt; targetNode = search0(root, e);</span><br><span class="line">    <span class="keyword">if</span>(targetNode==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;E&gt; parent = root.item.compareTo(e) ==<span class="number">0</span> ? <span class="keyword">null</span> :  findParentNode(root, e);</span><br><span class="line">    E value = targetNode.item;</span><br><span class="line">    <span class="comment">//删除的是叶子节点</span></span><br><span class="line">    <span class="keyword">if</span>(targetNode.left==<span class="keyword">null</span> &amp;&amp; targetNode.right==<span class="keyword">null</span> &amp;&amp; parent!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(targetNode==root) &#123;</span><br><span class="line">            root =<span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(parent.left==targetNode) &#123;</span><br><span class="line">            parent.left = <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            parent.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 删除的有两个子节点</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(targetNode.left!=<span class="keyword">null</span> &amp;&amp; targetNode.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        targetNode.item = removeMin(targetNode.right); <span class="comment">// 删除最左子节点</span></span><br><span class="line">     <span class="comment">// 删除的有一个子节点</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(targetNode.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(targetNode==root) &#123;</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(parent.left == targetNode) &#123;</span><br><span class="line">                parent.left  = targetNode.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                parent.right = targetNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(targetNode==root) &#123;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(parent.left == targetNode) &#123;</span><br><span class="line">                parent.left  = targetNode.right;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                parent.right = targetNode.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-8-平衡二叉树-AVL"><a href="#1-3-8-平衡二叉树-AVL" class="headerlink" title="1.3.8 平衡二叉树(AVL)"></a>1.3.8 平衡二叉树(AVL)</h4><blockquote>
<p>解决二叉排序树可能退化为单链表的问题</p>
<p>一颗空树 或左右两个子树的高度差绝对值不超过1 左右两个子树都是一颗平衡二叉树 主要实现有 红黑树 AVL 替罪羊树 Treap 伸展树等</p>
</blockquote>
<h5 id="1-3-8-1-左旋"><a href="#1-3-8-1-左旋" class="headerlink" title="1.3.8.1 左旋"></a>1.3.8.1 左旋</h5><blockquote>
<p>右子树高度大于左子树时</p>
</blockquote>
<blockquote>
<ol>
<li>创建一个新节点, 值等于当前的根节点的值</li>
<li>将新节点的左子树设为当前节点的左子树</li>
<li>将新节点的右子树设为当前节点的右子树的左子树</li>
<li>将当前节点的值换成右子节点的值</li>
<li>将当前节点的右子树设为右子树的右子树</li>
<li>将当前节点的左子树设为新节点</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(root.item);</span><br><span class="line">    newNode.left = root.left;</span><br><span class="line">    newNode.right = root.right.left;</span><br><span class="line">    root.item = root.right.item;</span><br><span class="line">    root.right = root.right.right;</span><br><span class="line">    root.left = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-3-8-2-右旋"><a href="#1-3-8-2-右旋" class="headerlink" title="1.3.8.2 右旋"></a>1.3.8.2 右旋</h5><blockquote>
<p>左子树高度大于右子树时</p>
</blockquote>
<blockquote>
<ol>
<li>创建新节点 值等于当前根节点的值</li>
<li>将新节点的右子树设置为当前节点的右子树</li>
<li>将新节点的左子树设为当前节点的左子树的右子树</li>
<li>把当前节点的值换为左子节点的值</li>
<li>把当前节点的左子树设置成左子树的左子树</li>
<li>将当前节点的右子树设为新节点</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(root.item);</span><br><span class="line">    newNode.right = root.right;</span><br><span class="line">    newNode.left = root.left.right;</span><br><span class="line">    root.item = root.left.item;</span><br><span class="line">    root.left = root.left.left;</span><br><span class="line">    root.right = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-3-8-3-双旋"><a href="#1-3-8-3-双旋" class="headerlink" title="1.3.8.3 双旋"></a>1.3.8.3 双旋</h5><blockquote>
<p>解决特殊情况下左旋和右旋不能平衡的问题</p>
<p>如果达到右旋条件</p>
<p>如果其左子树的的右子树高度大于左子树的左子树的高度</p>
<p>先对其左子树进行左旋 </p>
<p>如果达到左旋条件</p>
<p>如果右子树的左子树的高度大于右子树的右子树</p>
<p>先对右子树进行右旋</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加新节点后自平衡</span></span><br><span class="line"><span class="keyword">if</span>(leftHeight() - rightHeight() &gt;<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果根节点的左子节点的右子节点的高度大于左子节点的左子节点 先对左子节点进行左旋</span></span><br><span class="line">    <span class="keyword">if</span>(root.left!=<span class="keyword">null</span> &amp;&amp; height(root.left.right) &gt; height(root.left.left)) &#123;</span><br><span class="line">        leftRotate(root.left);</span><br><span class="line">        rightRotate(root);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        rightRotate(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(rightHeight() - leftHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果右子树的左子树大于右子树的右子树高度 先对右子树进行右旋</span></span><br><span class="line">    <span class="keyword">if</span>(root.right!=<span class="keyword">null</span> &amp;&amp; height(root.right.left) &gt; height(root.right.right)) &#123;</span><br><span class="line">        rightRotate(root.right);</span><br><span class="line">        leftRotate(root);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        leftRotate(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-多叉树"><a href="#1-4-多叉树" class="headerlink" title="1.4 多叉树"></a>1.4 多叉树</h3><blockquote>
<p>在面对海量数据时 使用二叉树存储会出现高度太大的问题 使用多叉树可降低高度</p>
<p>多叉树允许一个节点存储多个数据和节点</p>
</blockquote>
<h4 id="1-4-1-2-3树"><a href="#1-4-1-2-3树" class="headerlink" title="1.4.1 2-3树"></a>1.4.1 2-3树</h4><blockquote>
<p>B树的一种</p>
<p>2-3树的所有叶子节点都在同一层</p>
<p>有两个子节点的节点叫二节点 有三个的叫三节点 要求子节点非空即满 任然遵循二叉排序树的规则</p>
<p>插入规则</p>
<p>当一个元素插入到某个节点时</p>
<p>不能满足要求 则需要拆分 先向上拆 如果上层满 则拆本层 拆后</p>
</blockquote>
<h4 id="1-4-2-B树"><a href="#1-4-2-B树" class="headerlink" title="1.4.2 B树"></a>1.4.2 B树</h4><blockquote>
<p>MySql 底层所使用的数据结构</p>
<p>B树的阶 节点最多的子节点个数</p>
<p>搜索: 从根节点开始 对节点内的关键字序列进行二分查找 如果命中则结束 否则进入查询关键字所属的范围的子节点 重复 直到所对应的子节点指针为空 或是叶子节点</p>
<p>关键字集合分布在整棵树中 即叶子节点和非叶子节点都存放数据</p>
<p>搜索性能等价于在关键字全集内做一次二分查找</p>
<p>B+树与B树的改进在于B+树数据存储在叶子节点  将数据分段 更适合文件系统</p>
<p>B*树是B+树的变体 在B+的非根和非叶子节点上增加了指向兄弟节点的指针 空间使用率更高 新节点分配效率较低</p>
</blockquote>
<h3 id="1-5-图"><a href="#1-5-图" class="headerlink" title="1.5 图"></a>1.5 图</h3><blockquote>
<p>节点可以有0个或多个相邻元素 两个节点之间的连接称为边 节点可称作顶点 从一个顶点到另一个顶点的连线称为路径</p>
<p>无向图: 顶点之间的连线没有方向 有方向称为有向图</p>
<p>带权图: 边带有权值的图 也称为网</p>
<p>可用于表示多对多的关系</p>
<p>图有两种表示方式：二维数组(邻接矩阵) 和数组+链表(邻接表)</p>
</blockquote>
<h4 id="1-5-1-深度优先搜索"><a href="#1-5-1-深度优先搜索" class="headerlink" title="1.5.1 深度优先搜索"></a>1.5.1 深度优先搜索</h4><blockquote>
<p>从初始访问点出发 首先访问第一个邻接节点 再以该节点作为初始节点 访问它的第一个邻接节点 以此递归</p>
<p>基本思路:</p>
<ol>
<li>访问初始节点 并标记节点v为已访问</li>
<li>查找节点v的第一个邻接节点w</li>
<li>若w存在 则继续执行4 如果不存在 则回到第一步 将从v的下一节点继续</li>
<li>若w未被访问 对w进行深度优先遍历递归 继续步骤123</li>
<li>查找结点v的w邻接节点的下一邻接节点 转到步骤3</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">depthFirstSearch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历每个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i]) &#123;</span><br><span class="line">            depthFirstSearch(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">depthFirstSearch</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    System.out.print(vertex.get(i)+<span class="string">"=&gt;"</span>);</span><br><span class="line">    <span class="comment">// 将节点标记为已经过</span></span><br><span class="line">    visited[i] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 获取第一个相邻节点</span></span><br><span class="line">    <span class="keyword">int</span> neighbor = getFirstNeighbor(i);</span><br><span class="line">    <span class="keyword">while</span>(neighbor&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果该节点未遍历 则以该节点为初始节点进行递归遍历</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[neighbor]) &#123;</span><br><span class="line">            depthFirstSearch(neighbor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取下一相邻节点</span></span><br><span class="line">        neighbor  =getNextNeighbor(i, neighbor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取第一个相邻节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFirstNeighbor</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vertex.size(); j++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(graph[i][j]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取下一相邻节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNextNeighbor</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b+<span class="number">1</span>; i &lt; vertex.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(graph[a][i]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-5-2-广度优先搜索"><a href="#1-5-2-广度优先搜索" class="headerlink" title="1.5.2 广度优先搜索"></a>1.5.2 广度优先搜索</h4><blockquote>
<p>类似分层搜索 广度优先需要使用一个队列以保持访问过的节点的顺序 以便按这个顺序来访问这些节点的邻接节点</p>
<p>步骤：</p>
<ol>
<li>访问初始节点v并标记为节点v为以访问</li>
<li>节点v入队</li>
<li>当队列非空时 继续执行 否则算法结束</li>
<li>出队列 获得头节点u</li>
<li>查找节点u的第一个邻接节点w</li>
<li>若节点u的邻接节点w不存在 则转到步骤3 否则循环执行以下步骤<ul>
<li>若节点w未被访问 则访问节点w并标记为已访问</li>
<li>节点w入队列</li>
<li>查找节点u的继w邻接节点后的下一邻接节点w转到步骤6</li>
</ul>
</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">broadFirstSearch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertex.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i]) &#123;</span><br><span class="line">            broadFirstSearch(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">broadFirstSearch</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    System.out.print(vertex.get(i)+<span class="string">"==&gt;"</span>);</span><br><span class="line">    visited[i] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> u = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">    queue.addLast(i);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        u =	queue.removeFirst();</span><br><span class="line">        w = getFirstNeighbor(u);</span><br><span class="line">        <span class="keyword">while</span>(w&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[w]) &#123;</span><br><span class="line">                queue.addLast(w);</span><br><span class="line">                System.out.print(vertex.get(w)+<span class="string">"==&gt;"</span>);</span><br><span class="line">                visited[w] =  <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            w = getNextNeighbor(u, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-算法"><a href="#2-算法" class="headerlink" title="2 算法"></a>2 算法</h2><blockquote>
<p>衡量一个算法的效率有两种方法</p>
<ol>
<li><p>事后统计</p>
<p>运行程序然后计算耗费的时间 不能排除环境的影响</p>
</li>
<li><p>事前估算</p>
<p>通过分析算法的时间复杂度判断优秀的算法</p>
<p>一个算法花费的时间与算法中的语句执行次数成正比例</p>
<p>一个算法中语句的执行次数称为语句频度或时间频度  记为T(n) 当n趋于无穷大 常数项 低次项 和系数可以忽略 </p>
<p>时间频度的同数量级函数称为<strong>时间复杂度</strong> 用O(n)表示</p>
<ul>
<li><p>平均时间复杂度</p>
<p>输入到算法的实例均以等概率出现的情况下 该算法的运行时间</p>
</li>
<li><p>最坏时间复杂度</p>
<p>任何输入实例的运行时间的界限</p>
</li>
</ul>
</li>
<li><p>常见时间复杂度</p>
<ul>
<li>常数阶 O(1)</li>
<li>对数阶 O(logn)</li>
<li>线性阶 O(n)</li>
<li>线性对数阶 O(nlogn)</li>
<li>平方阶 O(n²)</li>
<li>立方阶 O(n³)</li>
<li>k次方阶 O(n^k)</li>
<li>指数阶 O(2^n)</li>
</ul>
</li>
<li><p>空间复杂度</p>
<p>衡量一个算法运行时所占的空间 n越大占用的空间越大</p>
<p>从用户体验看 更注重程序的运行速度</p>
</li>
</ol>
</blockquote>
<h3 id="2-1-递归"><a href="#2-1-递归" class="headerlink" title="2.1 递归"></a>2.1 递归</h3><blockquote>
<p>方法调用自己 每次传入不同的变量 有助于解决复杂问题 同时可让代码变得简洁</p>
<p>递归第一个执行的是 末端方法</p>
<p>递归回溯: 当达到退出条件时 会回到上一个方法栈 发生回溯</p>
<p>递归使用规则:</p>
<ol>
<li>执行一个方法时 就创建一个受保护的独立空间(栈空间)</li>
<li>方法的局部变量是独立的 不会相互影响</li>
<li>递归必须向退出递归的条件逼近 否则会造成栈溢出StackOverFlow</li>
<li>当方法执行完毕 或遇到return就会返回 遵守谁调用 就将结果返回给谁 同时当方法执行完毕或返回时 该方法执行完毕</li>
<li>如果方法中使用引用类型的变量 就会共享该引用类型的数据</li>
</ol>
</blockquote>
<h4 id="2-1-1-迷宫问题"><a href="#2-1-1-迷宫问题" class="headerlink" title="2.1.1 迷宫问题"></a>2.1.1 迷宫问题</h4><blockquote>
<p>二维数组表示迷宫  设有障碍(非元素)</p>
<p>计算小球从迷宫的左上角 走到出口(右下角)的最短路径</p>
<p>寻路策略会影响路径长短</p>
<ul>
<li>思路<ol>
<li>可通过递归回溯解决</li>
<li>将未走过的为止标记为0 墙标记为1 已走过的位置标记为2  死路标记为3</li>
</ol>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">wander</span><span class="params">(<span class="keyword">int</span>[][] map, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(map[map.length-<span class="number">2</span>][map[<span class="number">0</span>].length-<span class="number">2</span>]==<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果经过终点 返回true 结束递归</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(map[i][j]==<span class="number">0</span>) &#123;</span><br><span class="line">            map[i][j] =<span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 上 右 下 左</span></span><br><span class="line">            <span class="comment">//  0  未经过 1 墙 2 已经过 3 死路</span></span><br><span class="line">            <span class="keyword">if</span>(wander(map, i-<span class="number">1</span>, j)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(wander(map, i, j+<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(wander(map, i+<span class="number">1</span>, j)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(wander(map, i, j-<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果从该点起四个方向都无路可走 则标记为思路 在此回溯到上一个点</span></span><br><span class="line">                map[i][j] = <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果已经走过 直接返回false 不走回头路</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-八皇后问题"><a href="#2-1-2-八皇后问题" class="headerlink" title="2.1.2 八皇后问题"></a>2.1.2 八皇后问题</h4><blockquote>
<p>在8*8的国际象棋盘上拜访八个皇后 使其互相不能攻击</p>
<p>任意两个皇后不能处于同一行 同一列或同一斜线上</p>
<ul>
<li>思路<ol>
<li>第一个皇后先放在第一行第一列</li>
<li>第二个皇后放在第二行第一列 然后判断是否ok 如果不ok 继续放在第二列 第三列 依次把所有的列都放完 直到找到一个合适的位置</li>
<li>继续递归放剩下的皇后  直到所有皇后找到一个互不冲突的位置  即得到一个正确解</li>
<li>当得到一个正确解时 此时到达了末尾 触发退出条件  回溯到最后一个皇后 继续尝试剩下的列  当所有列试完 回溯到上一个皇后 以此类推</li>
<li>回头继续第一个皇后放第二列 继续从步骤2开开始循环</li>
<li>理论上要创建二维数组 但可通过算法使用一维数组解决 索引表示第几个皇后 每个皇后占据一行 元素表示皇后所在的列  当在同一列时 <strong>arr[n] == arr[i]</strong>  在同一斜线时  <strong>abs(arr[n-i]) == abs(abs(arr[n]) - abs(arr[i]))</strong></li>
</ol>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==MAX) &#123;</span><br><span class="line">        <span class="comment">// 找到一个正确解</span></span><br><span class="line">        print();</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX; i++) &#123;</span><br><span class="line">        arr[n] = i; <span class="comment">// 在尝试每一行的所有列</span></span><br><span class="line">        <span class="keyword">if</span>(judge(n)) &#123;</span><br><span class="line">            place(n+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">//  arr[i]==arr[n]是否处于同一列</span></span><br><span class="line">        <span class="comment">// Math.abs(n-i) ==Math.abs(arr[n] - arr[i]) 判断是否处在同一斜线上</span></span><br><span class="line">        <span class="keyword">if</span>(arr[i]==arr[n] || Math.abs(n-i) ==Math.abs(arr[n] - arr[i]) ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-排序"><a href="#2-2-排序" class="headerlink" title="2.2 排序"></a>2.2 排序</h3><blockquote>
<p>排序算法是将一组数据 以指定的顺序进行排列</p>
<p>分为</p>
<ul>
<li><p>内部排序</p>
<p>将数据都加载到内存中进行排序</p>
</li>
<li><p>外部排序</p>
<p>用于数据量太大 需要借助外部存储进行排序</p>
</li>
</ul>
</blockquote>
<h4 id="2-2-1-插入排序"><a href="#2-2-1-插入排序" class="headerlink" title="2.2.1 插入排序"></a>2.2.1 插入排序</h4><h5 id="2-2-1-1-直接插入排序"><a href="#2-2-1-1-直接插入排序" class="headerlink" title="2.2.1.1 直接插入排序"></a>2.2.1.1 直接插入排序</h5><blockquote>
<p>把n个待排序的元素看成一个有序列表和一个无序列表 开始时有序表只包含一个元素 无序表中包含有n-1个元素 排序过程一次从无序表取出第一个元素 把它的排序码依次与有序码进行比较 将它插入到有序表中的适当位置 使之成为新的有序表</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> insertVal = arr[i];</span><br><span class="line">    <span class="keyword">int</span> insertIndex = i-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; insertIndex &gt;= <span class="number">0</span>; insertIndex--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(insertVal&lt;arr[insertIndex]) &#123;</span><br><span class="line">            arr[insertIndex+<span class="number">1</span>] = arr[insertIndex];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[insertIndex+<span class="number">1</span>] = insertVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-1-2-希尔排序"><a href="#2-2-1-2-希尔排序" class="headerlink" title="2.2.1.2 希尔排序"></a>2.2.1.2 希尔排序</h5><blockquote>
<p>插入排序的改进版 将下标按步长分组  每组使用插入排序</p>
<p>每次缩小步长直到1</p>
<p>解决普通插入排序 要插入的是较小的数时 后移次数较多的问题</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> insertValue = <span class="number">0</span>, insertIndex = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 每次缩小步长为原来的为二分之一</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> step = arr.length / <span class="number">2</span>; step &gt; <span class="number">0</span>; step /=<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = step; i &lt; arr.length; i+=step) &#123;</span><br><span class="line">        insertValue = arr[i];</span><br><span class="line">        insertIndex = i - step;</span><br><span class="line">        <span class="keyword">for</span> (; insertIndex &gt;= <span class="number">0</span>; insertIndex-=step) &#123;</span><br><span class="line">            <span class="keyword">if</span>(insertValue&lt;arr[insertIndex]) &#123;</span><br><span class="line">                arr[insertIndex+step] = arr[insertIndex];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果发生了移位将元素插入到指定位置</span></span><br><span class="line">        <span class="keyword">if</span>(insertIndex+step!=i) &#123;</span><br><span class="line">            arr[insertIndex+step] = insertValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-选择排序"><a href="#2-2-2-选择排序" class="headerlink" title="2.2.2 选择排序"></a>2.2.2 选择排序</h4><h5 id="2-2-2-1-简单选择排序"><a href="#2-2-2-1-简单选择排序" class="headerlink" title="2.2.2.1 简单选择排序"></a>2.2.2.1 简单选择排序</h5><blockquote>
<p>第一次从arr[0] - arr[n-1]中选取最小值 与arr[0]交换 </p>
<p>第二次从arr[1] - arr[n-1] 中选取最小值与arr[1]交换</p>
<p>以此类推</p>
<p>一共有数组长度-1轮排序</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> minIndex = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; arr.length-<span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[minIndex]&gt;arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">            minIndex = j+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(minIndex!=i) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[minIndex];</span><br><span class="line">        arr[minIndex] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-2-2-堆排序"><a href="#2-2-2-2-堆排序" class="headerlink" title="2.2.2.2 堆排序"></a>2.2.2.2 堆排序</h5><blockquote>
<p>利用堆的数据结构完成排序</p>
<p>堆是一种特殊的二叉树</p>
<p>每个节点的值都大于或等于其左右子节点的值 称为大顶堆</p>
<p>每个节点的值都小于或等于其左右子节点的值 称为小顶堆 arr[i]&gt;=arr[2*i+1] &amp;&amp; arr[i]&gt;=arr[2*i+2]</p>
<p>大顶堆完成升序 小顶堆完成降序</p>
<p>基本思想:</p>
<ol>
<li>将待排序序列构造成一个大顶堆 最大值便是根节点</li>
<li>将最大值与末尾元素进行交换</li>
<li>将剩余n-1个元素重新构造成一个大顶堆 并反复执行步骤2 最后得到一个有序序列</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构建一个顶堆 数组末尾即为最大/最小元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123; </span><br><span class="line">        adjustHeap(arr, i, arr.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将最大元素依次提到数组末端 并重新调整堆</span></span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length- <span class="number">1</span>; i &gt;<span class="number">0</span>; i--) &#123;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        arr[i] = arr[<span class="number">0</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = temp;</span><br><span class="line">        adjustHeap(arr, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 每找到一个最大值时调整堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp =arr[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j =  i* <span class="number">2</span>+<span class="number">1</span>; j &lt; length; j=j*<span class="number">2</span>+<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j+<span class="number">1</span> &lt; length &amp;&amp; arr[j]&lt;arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">            j++;  <span class="comment">// 切换到右子节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果左右子节点的其中一个大于父节点 则于父节点交换 否则 无需交换</span></span><br><span class="line">        <span class="keyword">if</span>(arr[j]&gt;temp) &#123;</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-3-交换排序"><a href="#2-2-3-交换排序" class="headerlink" title="2.2.3 交换排序"></a>2.2.3 交换排序</h4><h5 id="2-2-3-1-冒泡排序"><a href="#2-2-3-1-冒泡排序" class="headerlink" title="2.2.3.1 冒泡排序"></a>2.2.3.1 冒泡排序</h5><blockquote>
<p>通过对待排序序列从前向后遍历 依次比较相邻元素的值 若发现逆序则交换 使值较大的元素逐渐移动到后部 就像水中的气泡逐渐往上冒</p>
<p>一共要进行数组长度-1循环</p>
<p>每次循环的比较次数逐渐减少</p>
<p>优化: 如果下一趟比较么没有进行交换 就说明序列有序 可提前结束</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">// 记录是否发生过交换</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length-<span class="number">1</span>-i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">            arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">            arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        flag = <span class="keyword">false</span>; <span class="comment">// 重置标记</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-2-3-2-快速排序"><a href="#2-2-3-2-快速排序" class="headerlink" title="2.2.3.2 快速排序"></a>2.2.3.2 快速排序</h5><blockquote>
<p> 对冒泡排序的改进</p>
<p>通过一次排序将要排序的数据分割成两部分 以此类推对两部分数据再次分割排序 可递归进行 空间换时间</p>
<p>通过头索引和尾索引相向遍历 以pivot为基准 将大于pivot的值放到右边 小于放到左边</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort0</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = left;</span><br><span class="line">    <span class="keyword">int</span> r = right;</span><br><span class="line">    <span class="keyword">int</span> pivot = arr[(right+left)/<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">while</span>(arr[l]&lt;pivot) &#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(arr[r]&gt;pivot) &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[l];</span><br><span class="line">        arr[l] = arr[r];</span><br><span class="line">        arr[r] = temp;</span><br><span class="line">        <span class="comment">// 如果对方交换过来的是pivot让对方向前一步以跳过pivot</span></span><br><span class="line">        <span class="keyword">if</span>(arr[l]==pivot) &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr[r]==pivot) &#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当l和r相等时 各向前一步</span></span><br><span class="line">    <span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">        l++;</span><br><span class="line">        r--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;r) &#123;</span><br><span class="line">        quickSort0(arr, left, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right&gt;l) &#123;</span><br><span class="line">        quickSort0(arr, l, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-4-归并排序"><a href="#2-2-4-归并排序" class="headerlink" title="2.2.4 归并排序"></a>2.2.4 归并排序</h4><blockquote>
<p>利用归并思想实现 采用分治法 将数组拆分成一个个小数组 对这些小数组排序 然后添加到一个临时数组</p>
<p>需要一个临时数组 时间换空间</p>
<p>总归并次数=数组长度-1</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort0</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left+right) / <span class="number">2</span>;</span><br><span class="line">        mergeSort0(arr, left, mid, temp);</span><br><span class="line">        mergeSort0(arr, mid+<span class="number">1</span>, right, temp);</span><br><span class="line">        merge(arr, left, right, mid, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> mid, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = left;</span><br><span class="line">    <span class="keyword">int</span> r = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;=mid &amp;&amp; r &lt;=right) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[l]&lt;arr[r]) &#123;</span><br><span class="line">            temp[t] = arr[l];</span><br><span class="line">            l++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            temp[t] = arr[r];</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        t++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将剩余数组填充到临时数组</span></span><br><span class="line">    <span class="keyword">while</span>(l&lt;=mid) &#123;</span><br><span class="line">        temp[t] = arr[l];</span><br><span class="line">        t++;</span><br><span class="line">        l++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(r&lt;=right) &#123;</span><br><span class="line">        temp[t] = arr[r];</span><br><span class="line">        t++;</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将排序好的片段填回原数组</span></span><br><span class="line">    t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;=right; i++) &#123;</span><br><span class="line">        arr[i] = temp[t++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-5-基数排序"><a href="#2-2-5-基数排序" class="headerlink" title="2.2.5 基数排序"></a>2.2.5 基数排序</h4><blockquote>
<p>通过键值的各个位的值 将要排序的元素分配至某些bucket(桶)中 达到排序的作用 典型的<strong>空间换时间</strong>算法</p>
<p>将所有待比较的数值统一为同样的数位长度 数位较短的数前面补0  放入相应的桶 然后遍历所有桶 完成一次排序</p>
<p>当数据量较大时 会出现OOM  负数需要特殊处理</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算最大位数</span></span><br><span class="line">    <span class="keyword">int</span> maxLenth = (Arrays.stream(arr).max().getAsInt()+<span class="string">""</span>).length();</span><br><span class="line">    <span class="comment">// 创建10个桶 0-9</span></span><br><span class="line">    <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">    <span class="comment">// 记录每个桶的元素数量</span></span><br><span class="line">    <span class="keyword">int</span>[] bucketElCount = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxLenth; i++, n*=<span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> bucketIndex = arr[j] / n % <span class="number">10</span>;</span><br><span class="line">            bucket[bucketIndex][bucketElCount[bucketIndex]] = arr[j];</span><br><span class="line">            bucketElCount[bucketIndex]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucket.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(bucketElCount[j]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j2 = <span class="number">0</span>; j2 &lt; bucketElCount[j]; j2++) &#123;</span><br><span class="line">                    arr[index++] = bucket[j][j2];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            bucketElCount[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-查找"><a href="#2-3-查找" class="headerlink" title="2.3 查找"></a>2.3 查找</h3><h4 id="2-3-1-线性查找"><a href="#2-3-1-线性查找" class="headerlink" title="2.3.1 线性查找"></a>2.3.1 线性查找</h4><blockquote>
<p>从头遍历数组 直到找到该值为止</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">linearSearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]==val) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-二分查找"><a href="#2-3-2-二分查找" class="headerlink" title="2.3.2 二分查找"></a>2.3.2 二分查找</h4><blockquote>
<p>需要有序列表  每次与中数组间值比较 如果大 递归向右查询 如果小 递归向左查询</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch0</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;right) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left+right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> midVal = arr[mid];</span><br><span class="line">    <span class="keyword">if</span>(val&gt;midVal) &#123;</span><br><span class="line">        <span class="keyword">return</span> binarySearch0(arr, mid+<span class="number">1</span>, right, val);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(val&lt;midVal) &#123;</span><br><span class="line">        <span class="keyword">return</span> binarySearch0(arr, left, mid-<span class="number">1</span>, val);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-3-插值查找"><a href="#2-3-3-插值查找" class="headerlink" title="2.3.3 插值查找"></a>2.3.3 插值查找</h4><blockquote>
<p>类似于二分查找  每次以自适应的mid开始查找 将折半查找中的求mid公式 改为<br>$$<br>mid = low+(key-arr[low])*(high-low)/arr[hign]-arr[low]<br>$$<br>在数据量特别大时可能会遇到IndexOutOfBounds 和StackOverFlow</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insertValueSearch0</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;right || arr[<span class="number">0</span>]&gt;val || arr[arr.length-<span class="number">1</span>]&lt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = left +(right-left) * (val-arr[left]) / (arr[right] - arr[left]);</span><br><span class="line">    <span class="keyword">int</span> midVal = arr[mid];</span><br><span class="line">    <span class="keyword">if</span>(midVal &gt; val) &#123;</span><br><span class="line">        <span class="keyword">return</span> insertValueSearch0(arr, left, mid-<span class="number">1</span>, val);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(midVal&lt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> insertValueSearch0(arr, mid+<span class="number">1</span>, right, val);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-4-斐波那契-黄金分割-查找"><a href="#2-3-4-斐波那契-黄金分割-查找" class="headerlink" title="2.3.4 斐波那契(黄金分割)查找"></a>2.3.4 斐波那契(黄金分割)查找</h4><blockquote>
<p>将数组按黄金分割比分为两部分</p>
<p>中间节点计算公式</p>
<p>mid=low+F[k-1]-1</p>
<p>F(k-1)= (F[k-1]-1) + (F[k-2]-1)+1</p>
<p>只要顺序表长度为F[k]-1  可以将该表分成长度为F[k-1]和F[K-2]的两段 </p>
<p>如果长度不等于F[k]-1 所以需要将原来的顺序表长度增加至F[k]-1</p>
<p>顺序表要求有序 需要一个斐波那契数列做为辅助</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fibonacciSearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = arr.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] f = fibonacci(); <span class="comment">// 获取斐波那契数列</span></span><br><span class="line">    <span class="keyword">while</span>(high&gt;f[k]-<span class="number">1</span>) &#123;k++;&#125;</span><br><span class="line">    <span class="comment">// 扩增数组至斐波那契数列中某个元素的长度</span></span><br><span class="line">    <span class="keyword">int</span>[] temp = Arrays.copyOf(arr, f[k]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = high+<span class="number">1</span>; i &lt; f[k]; i++) &#123;</span><br><span class="line">        temp[i] = arr[high]; <span class="comment">// 用最高位补齐</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high) &#123;</span><br><span class="line">        mid = low +f[k-<span class="number">1</span>]-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp[mid]&lt;val) &#123;</span><br><span class="line">            low = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 找出右半段的黄金分割点</span></span><br><span class="line">            k-=<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp[mid]&gt;val) &#123;</span><br><span class="line">            high = mid-<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 找到左半段的黄金分割点</span></span><br><span class="line">            k--;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(mid&lt;=high) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> high;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-编码"><a href="#2-4-编码" class="headerlink" title="2.4 编码"></a>2.4 编码</h3><h4 id="2-4-1-霍夫曼编码"><a href="#2-4-1-霍夫曼编码" class="headerlink" title="2.4.1 霍夫曼编码"></a>2.4.1 霍夫曼编码</h4><blockquote>
<p>利用霍夫曼树 对数据进行编码</p>
<p>将数据的主成分提取 生成一颗霍夫曼树</p>
<p>一个根节点与左子节点的距离为0 与右子节点的距离为1</p>
<p>各个编码互不为前缀</p>
<p>可对数据进行无损压缩</p>
<p>对重复数据多的压缩率较高</p>
</blockquote>
<ul>
<li><p>构建霍夫曼编码表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getHuffmanCode</span><span class="params">(Node&lt;E&gt; node, String code, StringBuilder sb, Map&lt;E, String&gt; map )</span></span>&#123;</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder(sb);</span><br><span class="line">    builder.append(code);</span><br><span class="line">    <span class="keyword">if</span>(node!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(node.value==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 左子树编码为0 右子树编码为1 依次递归查找子叶节点 查找过程经过路径即为改数据的编码</span></span><br><span class="line">            getHuffmanCode(node.left, <span class="string">"0"</span>, builder, map);</span><br><span class="line">            getHuffmanCode(node.right, <span class="string">"1"</span>, builder, map);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(node.value, builder.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] compress(<span class="meta">@NotNull</span> Map&lt;Character, String&gt; map, <span class="meta">@NotNull</span> String content) &#123;</span><br><span class="line">    StringBuilder huffmanCodeStr = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : content.toCharArray()) &#123;</span><br><span class="line">        huffmanCodeStr.append(map.get(c));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = (huffmanCodeStr.length() + <span class="number">7</span>) / <span class="number">8</span>; <span class="comment">// 计算需要的字节数组长度</span></span><br><span class="line">    <span class="keyword">byte</span>[] huffmanCode = <span class="keyword">new</span> <span class="keyword">byte</span>[len+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    String str = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; huffmanCodeStr.length(); i+=<span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">8</span>&gt;huffmanCodeStr.length()) &#123;</span><br><span class="line">            str = huffmanCodeStr.substring(i);</span><br><span class="line">            huffmanCode[index] =  (<span class="keyword">byte</span>) Integer.parseInt(str, <span class="number">2</span>);</span><br><span class="line">            huffmanCode[index+<span class="number">1</span>] = (<span class="keyword">byte</span>) str.length();  <span class="comment">// 末尾追加一个字节 存储最后不足一字节的二进制位长度</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            str = huffmanCodeStr.substring(i, i+<span class="number">8</span>);</span><br><span class="line">            huffmanCode[index] = (<span class="keyword">byte</span>) Integer.parseInt(str, <span class="number">2</span>);</span><br><span class="line">            <span class="comment">// 最后一字节如果长度刚好为8</span></span><br><span class="line">          <span class="keyword">if</span>(i+<span class="number">8</span>==huffmanCodeStr.length()) &#123;</span><br><span class="line">                huffmanCode[index+<span class="number">1</span>] = (<span class="keyword">byte</span>) str.length();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> huffmanCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String  <span class="title">decompress</span><span class="params">(HuffmanTree&lt;Character&gt; tree, @NotNull <span class="keyword">byte</span>[] code)</span> </span>&#123;</span><br><span class="line">    StringBuilder huffmanStr = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    String binaryString  = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;code.length-<span class="number">2</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">byte</span> b = code[i]; </span><br><span class="line">        binaryString = Integer.toBinaryString(b | <span class="number">256</span>); <span class="comment">// 不足8位时补位</span></span><br><span class="line">        binaryString = binaryString.substring(binaryString.length()-<span class="number">8</span>); <span class="comment">// 截取1字节 最后8位</span></span><br><span class="line">        huffmanStr.append(binaryString);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 末尾字节需要特殊处理</span></span><br><span class="line">    <span class="keyword">byte</span> len = code[code.length-<span class="number">1</span>]; <span class="comment">// 获取末尾长度标记字节</span></span><br><span class="line">    <span class="keyword">byte</span> b = code[code.length-<span class="number">2</span>]; <span class="comment">// 末尾字节</span></span><br><span class="line">    String string = Integer.toBinaryString(b | <span class="number">256</span>);</span><br><span class="line">    <span class="comment">// 长度刚好或等于指定长度</span></span><br><span class="line">    binaryString = len &lt; <span class="number">8</span> ? string.substring(string.length() - len) : string.substring(string.length()-<span class="number">8</span>);</span><br><span class="line">    huffmanStr.append(binaryString);</span><br><span class="line">    <span class="keyword">char</span>[] charArray = huffmanStr.toString().toCharArray();</span><br><span class="line">    huffmanStr = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    Node&lt;Character&gt; node = tree.getRoot();</span><br><span class="line">    <span class="comment">// bi</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; charArray.length;) &#123;</span><br><span class="line">        node = tree.getRoot();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(node.value==<span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">switch</span>(charArray[i]) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'0'</span>:</span><br><span class="line">                        node = node.left;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'1'</span>:</span><br><span class="line">                        node = node.right;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                huffmanStr.append(node.value);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> huffmanStr.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="2-5-分治法"><a href="#2-5-分治法" class="headerlink" title="2.5 分治法"></a>2.5 分治法</h3><blockquote>
<p>分而治之 思想的体现 将一个大问题拆分成若干个相似的小问题 再把小问题拆成更小的的问题 直到最后可以拆分成直接求解的问题 原问题的解就是小问题的解的合并</p>
<p>基本步骤：</p>
<ol>
<li>分解</li>
<li>解决</li>
<li>合并</li>
</ol>
</blockquote>
<h4 id="2-5-1-汉诺塔"><a href="#2-5-1-汉诺塔" class="headerlink" title="2.5.1 汉诺塔"></a>2.5.1 汉诺塔</h4><blockquote>
<p>设三个柱A B C</p>
<p>盘数 n</p>
<p>当n=1 A -&gt; C</p>
<p>当n&gt;=2</p>
<p>A-&gt;B</p>
<p>A-&gt;C</p>
<p>B-&gt;C </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> num, String a, String b, String c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(a+<span class="string">"==&gt;"</span>+c);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 借助c 将 a 移动到b</span></span><br><span class="line">        move(num-<span class="number">1</span>, a, c, b);</span><br><span class="line">        System.out.println(a+<span class="string">"==&gt;"</span>+c);</span><br><span class="line">        <span class="comment">// 借助a 将 b 移动到c </span></span><br><span class="line">        move(num-<span class="number">1</span>, b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-动态规划"><a href="#2-6-动态规划" class="headerlink" title="2.6 动态规划"></a>2.6 动态规划</h3><blockquote>
<p>将大问题划分为小问题进行解决 从而进一步获取最优解的处理算法</p>
<p>与分治算法类似 先求解子问题 然后从这些子问题的解得到原问题的解</p>
<p>与分治法不同的是 适合用于动态规划求解的问题 经分解后得到的子问题 往往不是相互独立的 下一阶段的求解是建立在上一阶段的解的基础上 进行进一步的求解</p>
<p>动态规划可通过填表的方式来逐步推进 得到最优解</p>
</blockquote>
<h4 id="2-6-1-背包问题"><a href="#2-6-1-背包问题" class="headerlink" title="2.6.1 背包问题"></a>2.6.1 背包问题</h4><blockquote>
<p>给定一容量有限的背包 若干具有一定价值和重量的物品 如何选取物品是的放入背包的物品价值最大 </p>
<p>又分为01背包(物品不能重复)和完全背包(物品可重复)</p>
<p>思路:</p>
<p>每次遍历到第i个物品 根据w[i]和v[i]来确定是否需要将该物品放入背包中 即对于给定的n个物品 设w[i] v[i] 分别为物品的重量 价格 c为背包容量 再令v[i][j]表示前i个物品中能够装入容量为j的背包的最大价值</p>
<p>v[i][0]=v[0][j]=0 第一行第一列 0</p>
<p>当w[i]&gt;j时 v[i][j] = v[i-1][j]  (准备加入背包的物品大于当前背包的容量 直接将上一个单元个的数据装入)</p>
<p>当j&gt;=w[i]时 v[i][j] = max(v[i-1][j], v[i-1][j-w[i]]+v[i])  当准备加入背包的物品小于等于当前背包的容量 求上一单元格  v[i-1][j-w[i]] 表示装入i-1个商品的总价值(j-w[i]为装入新物品后剩余容量所对应的价值)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] w = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;; <span class="comment">// 物品重量</span></span><br><span class="line">    <span class="keyword">int</span>[] v = &#123;<span class="number">500</span>, <span class="number">1000</span>, <span class="number">1500</span>, <span class="number">3000</span>&#125;; <span class="comment">//  物品价值</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">6</span>; <span class="comment">// 背包容量</span></span><br><span class="line">    <span class="comment">// 物品与各个容量的背包与价格关系对应表</span></span><br><span class="line">    <span class="keyword">int</span>[][] table = <span class="keyword">new</span> <span class="keyword">int</span>[w.length+<span class="number">1</span>][max+<span class="number">1</span>]; </span><br><span class="line">    <span class="comment">// 物品存放路径</span></span><br><span class="line">    <span class="keyword">int</span>[][] path = <span class="keyword">new</span> <span class="keyword">int</span>[w.length+<span class="number">1</span>][max+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; table.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; table[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果要存放的物品大于当前背包的容量 则在该单元格内复制上一物品的价格</span></span><br><span class="line">            <span class="keyword">if</span>(w[i-<span class="number">1</span>] &gt; j) &#123;</span><br><span class="line">                table[i][j] = table[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(table[i-<span class="number">1</span>][j]&lt; v[i-<span class="number">1</span>]+table[i-<span class="number">1</span>][j-w[i-<span class="number">1</span>]] ) &#123;</span><br><span class="line">                    <span class="comment">// 如果要存放的物品重量小于当前背包重量 且在加入该被背包后剩余容量所对应物品价值 大于上一单元格价值 </span></span><br><span class="line">                    <span class="comment">// 则为当前单元格赋值 且记录路径</span></span><br><span class="line">                    table[i][j] = v[i-<span class="number">1</span>]+table[i-<span class="number">1</span>][j-w[i-<span class="number">1</span>]];</span><br><span class="line">                    path[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    table[i][j] = table[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] arr : table) &#123;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = path.length-<span class="number">1</span>, j = path[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(path[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"put "</span>+i+<span class="string">" in"</span>);</span><br><span class="line">            j -= w[i-<span class="number">1</span>];  <span class="comment">// 在找到一件物品后 减去该物品的重量 定位到下一物品所在的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-7-KMP"><a href="#2-7-KMP" class="headerlink" title="2.7 KMP"></a>2.7 KMP</h3><blockquote>
<p>字符串查找匹配算法 用于在一个文本内 查找一个字符串出现的位置 相比于传统的暴力匹配算法 效率更高</p>
<p>利用之前判断过的信息 通过一个next数组 保存模式串前后最长公共子序列的长度 每次回溯时 通过next数组找到 前面匹配过的位置 省去了大量计算时间</p>
<p>当匹配失败时 向后移动</p>
<p>移动位数 = 已匹配字符数 - 对应的部分匹配值</p>
<p>部分匹配表</p>
<p>利用字符串的前缀和后缀</p>
<p>共有元素数量  子串中前缀与后缀相同元素的数量</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] kmpNext(String str) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[str.length()];</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>,j=<span class="number">0</span> ; i &lt; str.length(); i++) &#123;</span><br><span class="line">        <span class="comment">// 如果该位置不匹配 则通过部分匹配表向前查找</span></span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; str.charAt(i)!=str.charAt(j)) &#123;</span><br><span class="line">            j = next[j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果匹配 移到下一个位置</span></span><br><span class="line">        <span class="keyword">if</span>(str.charAt(i)==str.charAt(j)) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmpMatch</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> [] next = kmpNext(str2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; str1.length(); i++) &#123;</span><br><span class="line">        <span class="comment">// 如果不匹配 回退到部分匹配表中的上一相同子串出现的位置</span></span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; str1.charAt(i) != str2.charAt(j)) &#123;</span><br><span class="line">            j = next[j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(str1.charAt(i)==str2.charAt(j)) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j==str2.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> i - j +<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-8-贪心算法"><a href="#2-8-贪心算法" class="headerlink" title="2.8 贪心算法"></a>2.8 贪心算法</h3><blockquote>
<p>指在对问题进行求解时 在每一步选择中都采取最好或最优的选择 从而希望能够导致结果是最好或最优的算法</p>
<p>最后得到的结果不一定是最优解</p>
</blockquote>
<h4 id="2-8-1-集合覆盖问题"><a href="#2-8-1-集合覆盖问题" class="headerlink" title="2.8.1 集合覆盖问题"></a>2.8.1 集合覆盖问题</h4><blockquote>
<p>假设有n个广播电台 每个广播电台可覆盖一些城市</p>
<p>求用最少的广播电台覆盖全部城市</p>
<p>思路:</p>
<ol>
<li>遍历所有广播电台 找到一个覆盖了最多未覆盖地区的电台</li>
<li>将该电台加入到一个集合 并把该电台覆盖的地区在下次比较时去掉</li>
<li>重复第1步直到覆盖了全部的地区</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, HashSet&lt;String&gt;&gt; broadcast = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">HashSet&lt;String&gt; b1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">b1.add(<span class="string">"A"</span>);</span><br><span class="line">b1.add(<span class="string">"B"</span>);</span><br><span class="line">b1.add(<span class="string">"C"</span>);</span><br><span class="line"></span><br><span class="line">HashSet&lt;String&gt; b2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">b2.add(<span class="string">"C"</span>);</span><br><span class="line">b2.add(<span class="string">"D"</span>);</span><br><span class="line"></span><br><span class="line">HashSet&lt;String&gt; b3 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">b3.add(<span class="string">"B"</span>);</span><br><span class="line">b3.add(<span class="string">"C"</span>);</span><br><span class="line"></span><br><span class="line">HashSet&lt;String&gt; b4 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">b4.add(<span class="string">"D"</span>);</span><br><span class="line">b4.add(<span class="string">"E"</span>);</span><br><span class="line"></span><br><span class="line">broadcast.put(<span class="string">"B1"</span>, b1);</span><br><span class="line">broadcast.put(<span class="string">"B2"</span>, b2);</span><br><span class="line">broadcast.put(<span class="string">"B3"</span>, b3);</span><br><span class="line">broadcast.put(<span class="string">"B4"</span>, b4);</span><br><span class="line"></span><br><span class="line">HashSet&lt;String&gt; allAreas  = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">allAreas.addAll(Arrays.asList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(allAreas);</span><br><span class="line">List&lt;String&gt; selects = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">HashSet&lt;String&gt; tempSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">String sKey = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(allAreas.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">    sKey = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 遍历所有电台</span></span><br><span class="line">    <span class="keyword">for</span>(String k : broadcast.keySet()) &#123;</span><br><span class="line">        tempSet.clear();</span><br><span class="line">        tempSet.addAll(broadcast.get(k));</span><br><span class="line">        <span class="comment">// 获得当前电台可覆盖区域与所有未覆盖区域的交集</span></span><br><span class="line">        <span class="comment">//				broadcast.get(k).retainAll(allAreas);</span></span><br><span class="line">        tempSet.retainAll(allAreas);</span><br><span class="line">        <span class="comment">//				System.out.println(k+"==&gt;"+tempSet);</span></span><br><span class="line">        <span class="comment">//				System.exit(0);</span></span><br><span class="line">        <span class="comment">// 从所有电台中获得可覆盖未覆盖区域最多的电台 贪婪的体现</span></span><br><span class="line">        <span class="keyword">int</span> a = tempSet.size();</span><br><span class="line">        <span class="keyword">int</span> b = sKey == <span class="keyword">null</span> ? <span class="number">0</span>: broadcast.get(sKey).size();</span><br><span class="line">        <span class="keyword">if</span>(tempSet.size()&gt;<span class="number">0</span> &amp;&amp; a &gt; b) &#123;</span><br><span class="line">            sKey = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sKey!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        selects.add(sKey);</span><br><span class="line">        <span class="comment">// 从未覆盖区域中移除 一次比较后可覆盖区域最多的电台的覆盖区域</span></span><br><span class="line">        allAreas.removeAll(broadcast.get(sKey));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(selects);</span><br></pre></td></tr></table></figure>

<h3 id="2-9-Prim算法"><a href="#2-9-Prim算法" class="headerlink" title="2.9 Prim算法"></a>2.9 Prim算法</h3><blockquote>
<p>可解决图中可以连通各个节点的总路径最短问题</p>
<p>最小生成树</p>
<ul>
<li>给定一个带权的无向连通图使树上所有边上权的总和最小 称为最小生成树</li>
<li>N个顶点 一定有N-1条边</li>
<li>包含全部顶点</li>
<li>N-1条边都在图中</li>
</ul>
<p>在包含n个顶点的连通图中 找出只有(n-1)条边包含所有n个顶点的联通子图 称为极小联通子图</p>
<p>基本思路:</p>
<ol>
<li>设G=(V, E)是联通网 T=(U,D) 为最小生成树 V, U 是顶点集合 E,D 是边的集合</li>
<li>若集合U中顶点ui与集合V-U中的顶点vj存在边 则寻找这些边中权值最小的边 但不能构成回路 将顶点vj加入集合D中 将边(ui, uj)加入集合中 标记visited[vj]=1</li>
<li>重复步骤2 直到所有顶点都标记为为访问过 此时D中有n-1条边</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> verxs = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[verxs];</span><br><span class="line"><span class="keyword">char</span>[] site = &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[][] weights = <span class="keyword">new</span> <span class="keyword">int</span>[verxs][verxs];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weights.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; weights[i].length; j++) &#123;</span><br><span class="line">        weights[i][j] = <span class="number">10000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 双向设置路径权值</span></span><br><span class="line">weights[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">weights[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">4</span>;</span><br><span class="line">weights[<span class="number">1</span>][<span class="number">3</span>] = <span class="number">5</span>;</span><br><span class="line">weights[<span class="number">2</span>][<span class="number">4</span>] = <span class="number">6</span>;</span><br><span class="line">weights[<span class="number">3</span>][<span class="number">5</span>] = <span class="number">3</span>;</span><br><span class="line">weights[<span class="number">4</span>][<span class="number">5</span>] = <span class="number">7</span>;</span><br><span class="line">weights[<span class="number">1</span>][<span class="number">4</span>] = <span class="number">4</span>;</span><br><span class="line">weights[<span class="number">1</span>][<span class="number">5</span>] = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">weights[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">weights[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">weights[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">5</span>;</span><br><span class="line">weights[<span class="number">4</span>][<span class="number">2</span>] = <span class="number">6</span>;</span><br><span class="line">weights[<span class="number">5</span>][<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">weights[<span class="number">5</span>][<span class="number">4</span>] = <span class="number">7</span>;</span><br><span class="line">weights[<span class="number">4</span>][<span class="number">1</span>] = <span class="number">4</span>;</span><br><span class="line">weights[<span class="number">5</span>][<span class="number">1</span>] = <span class="number">9</span>;</span><br><span class="line"><span class="comment">// 起始点</span></span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">visited[start] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> minWeight  = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">int</span> a = -<span class="number">1</span>, b =-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; verxs; i++) &#123;</span><br><span class="line">    <span class="comment">// 已访问的节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; verxs; j++) &#123;</span><br><span class="line">        <span class="comment">//  从当前已访问的节点开始找到权值最小的相邻节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; verxs; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[j] == <span class="number">1</span> &amp;&amp; visited[k]==<span class="number">0</span> &amp;&amp; weights[j][k] &lt;  minWeight) &#123;</span><br><span class="line">                minWeight = weights[j][k];</span><br><span class="line">                <span class="comment">// 标记已找到的点</span></span><br><span class="line">                a = j;</span><br><span class="line">                b = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"&lt;"</span>+site[a]+<span class="string">","</span>+site[b]+<span class="string">"&gt; ==&gt;"</span>+minWeight);</span><br><span class="line">    <span class="comment">// 将找到的节点标记为已访问</span></span><br><span class="line">    visited[b] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 重置最小权值</span></span><br><span class="line">    minWeight=<span class="number">10000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-0-Kruskal算法"><a href="#3-0-Kruskal算法" class="headerlink" title="3.0 Kruskal算法"></a>3.0 Kruskal算法</h3><blockquote>
<p>解决最小生成树问题</p>
<p>基本思路</p>
<p>按照权值 从大到小选择n-1条边 并保证n-1条边不构成回路</p>
<p>构造一个只含n个顶点的森林 然后按权值从小到大从连通网中选择边加入到森林中 并使森林不产生回路 直到森林变成一棵树为止</p>
<p>判断回路:</p>
<p>最大顶点: 将所有顶点按升序排列好之后 某个顶点的终点即为最大顶点 </p>
<p>加入森林的两个顶点不能都指向同一顶点 否则将构成回路</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="keyword">char</span> node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nodes[i]==node) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getEnd</span><span class="params">(<span class="keyword">int</span>[] ends, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(ends[i]!=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 指向该顶点的下一邻接顶点 直到指向终点(ends[i]=0)</span></span><br><span class="line">        i = ends[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Edge&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 保存所有顶点的终点</span></span><br><span class="line">    <span class="keyword">int</span>[] ends = <span class="keyword">new</span> <span class="keyword">int</span>[edgeNum];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edgeNum; i++) &#123;</span><br><span class="line">        <span class="comment">// 获取起始顶点位置</span></span><br><span class="line">        <span class="keyword">int</span> start = getIndex(edges[i].start);</span><br><span class="line">        <span class="comment">// 获取起始顶点位置</span></span><br><span class="line">        <span class="keyword">int</span> end = getIndex(edges[i].end);</span><br><span class="line">        <span class="comment">// 获取两个位置的终点</span></span><br><span class="line">        <span class="keyword">int</span> a = getEnd(ends, start);</span><br><span class="line">        <span class="keyword">int</span> b = getEnd(ends, end);</span><br><span class="line">        <span class="comment">// 如果终点不同 则找到一条边</span></span><br><span class="line">        <span class="keyword">if</span>(a!=b) &#123;</span><br><span class="line">            ends[a] = b;</span><br><span class="line">            res.add(edges[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(Edge e : res) &#123;</span><br><span class="line">        System.out.println(e.weight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-Dijkstra算法"><a href="#3-1-Dijkstra算法" class="headerlink" title="3.1 Dijkstra算法"></a>3.1 Dijkstra算法</h3><blockquote>
<p>解决 从一个顶点到其他顶点的最短路径问题</p>
<p>主要特点是以七十点为中心向外层层扩散 直到扩展到终点为止</p>
<p>设置出发点为v 顶点集合为V{v1, v2…vj} v到V中各顶点的距离构成集合Dis Dis集合记录看v到图中各个顶点的距离(到自身可以看作0, v到vi距离对应为di)</p>
<ol>
<li>从Dis中选择值最小的di并移出Dis集合 同时移出V集合中对应的顶点vi 此时的v到vi即为最短路径</li>
<li>更新Dis集合 更新规则为 比较v到V集合中顶点的距离值 与v通过vi到V集合中顶点的距离值 保留较小的一个(同时更新节点的前驱节点为vi 表示已访问)</li>
<li>重复执行以上步骤 直到最短路径顶点为目标顶点即可结束</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] visited;  <span class="comment">// 已访问过的节点</span></span><br><span class="line"><span class="keyword">int</span>[] preVisited; <span class="comment">// 已访问过的节点的前驱节点</span></span><br><span class="line"><span class="keyword">int</span>[] dis; <span class="comment">// 初始节点与其他各个节点的距离</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    visited[index] = <span class="number">1</span>;</span><br><span class="line">    dis[index] = <span class="number">0</span>;</span><br><span class="line">    update(index);</span><br><span class="line">    <span class="comment">// 更新剩余顶点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dis.length; i++) &#123;</span><br><span class="line">        index  = updateIndex();</span><br><span class="line">        update(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.length ; i++) &#123;</span><br><span class="line">        <span class="comment">// 计算当前起始节点与当前节点和当前节点与下一邻接节点的距离之和 并与起始节点与该邻接节点的直接距离比较 取最小值 得到新的起始节点与其他节点的距离最小值</span></span><br><span class="line">        len = dis[index] + weights[index][i];</span><br><span class="line">        <span class="keyword">if</span>(visited[i]==<span class="number">0</span> &amp;&amp; len &lt; dis[i]) &#123;</span><br><span class="line">            preVisited[i] = index; <span class="comment">// 记录前驱节点</span></span><br><span class="line">            dis[i] = len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">updateIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>, min = <span class="number">65535</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 找到与起始顶点距离最短的顶点作为下一顶点</span></span><br><span class="line">        <span class="keyword">if</span>(visited[i]==<span class="number">0</span> &amp;&amp; dis[i] &lt; min) &#123;</span><br><span class="line">            min = dis[i];</span><br><span class="line">            index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[index] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-Floyd算法"><a href="#3-2-Floyd算法" class="headerlink" title="3.2 Floyd算法"></a>3.2 Floyd算法</h3><blockquote>
<p>求各个顶点到其他顶点的最短路径</p>
<p>基本思路</p>
<p>找一个中心点 并以这个中心点的为基准 求 相邻两点经过该点的路径 与两点直接路径的最小值 所有情况进行遍历 从而更新 距离关系 和前驱关系</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; nodes.length; k++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nodes.length; j++) &#123;</span><br><span class="line">            len = weights[i][k] + weights[k][j];</span><br><span class="line">            <span class="keyword">if</span>(len &lt; weights[i][j]) &#123;</span><br><span class="line">                weights[i][j] = len;</span><br><span class="line">                pre[i][j] = pre[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-马踏棋盘问题"><a href="#3-3-马踏棋盘问题" class="headerlink" title="3.3 马踏棋盘问题"></a>3.3 马踏棋盘问题</h3><blockquote>
<p>在8 * 8的国际象棋盘上 马按照马走日字进行移动 要求每个放个只走一次 并踏遍所有方格</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travelBoard</span><span class="params">(<span class="keyword">int</span>[][] chessBoard, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">    Point p = <span class="keyword">new</span> Point(x, y);</span><br><span class="line">    visited[x][y] = <span class="keyword">true</span>;</span><br><span class="line">    List&lt;Point&gt; ps = nextPoints(p); <span class="comment">// 查找该点周围可以走的点</span></span><br><span class="line">    chessBoard[x][y] = step;</span><br><span class="line">    sort(ps); <span class="comment">//  贪心算法优化 从邻点最少的点开始遍历(非降序排序)</span></span><br><span class="line">    <span class="keyword">while</span>(!ps.isEmpty()) &#123;</span><br><span class="line">        Point point = ps.remove(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(!visited[point.x][point.y]) &#123;</span><br><span class="line">            <span class="comment">// 以下一个点为中心递归继续查找 深度优先遍历</span></span><br><span class="line">            travelBoard(chessBoard, point.x, point.y, step+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有走完 说明该点行不通</span></span><br><span class="line">    <span class="keyword">if</span>(step &lt; X * Y &amp;&amp; !finished) &#123;</span><br><span class="line">        chessBoard[x][y] = <span class="number">0</span>;</span><br><span class="line">        visited[x][y] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        finished = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查找点周围的8个可移动的位置</span></span><br><span class="line"><span class="function">List&lt;Point&gt; <span class="title">nextPoints</span><span class="params">(Point p)</span></span>&#123;</span><br><span class="line">    List&lt;Point&gt; ps = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(p.x - <span class="number">2</span> &gt;= <span class="number">0</span> &amp;&amp; p.y-<span class="number">1</span>&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">        ps.add(<span class="keyword">new</span> Point(p.x-<span class="number">2</span>, p.y-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p.x-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; p.y-<span class="number">2</span>&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">        ps.add(<span class="keyword">new</span> Point(p.x-<span class="number">1</span>, p.y-<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p.x+<span class="number">2</span>&lt;X  &amp;&amp; p.y-<span class="number">1</span>&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">        ps.add(<span class="keyword">new</span> Point(p.x+<span class="number">2</span>, p.y-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p.x+<span class="number">1</span>&lt;X  &amp;&amp; p.y-<span class="number">2</span>&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">        ps.add(<span class="keyword">new</span> Point(p.x+<span class="number">1</span>, p.y-<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p.x-<span class="number">2</span>&gt;=<span class="number">0</span>  &amp;&amp; p.y+<span class="number">1</span>&lt;Y) &#123;</span><br><span class="line">        ps.add(<span class="keyword">new</span> Point(p.x-<span class="number">2</span>, p.y+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p.x-<span class="number">1</span>&gt;=<span class="number">0</span>  &amp;&amp; p.y+<span class="number">2</span>&lt;Y) &#123;</span><br><span class="line">        ps.add(<span class="keyword">new</span> Point(p.x-<span class="number">1</span>, p.y+<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p.x+<span class="number">1</span> &lt; X  &amp;&amp; p.y+<span class="number">2</span>&lt;Y) &#123;</span><br><span class="line">        ps.add(<span class="keyword">new</span> Point(p.x+<span class="number">1</span>, p.y+<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p.x+<span class="number">2</span> &lt; X  &amp;&amp; p.y+<span class="number">1</span>&lt;Y) &#123;</span><br><span class="line">        ps.add(<span class="keyword">new</span> Point(p.x+<span class="number">2</span>, p.y+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a>
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/12/SpringBoot%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/" rel="prev" title="SpringBoot入门指南">
      <i class="fa fa-chevron-left"></i> SpringBoot入门指南
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/04/17/java%E4%B9%8BIO%E6%B5%81/" rel="next" title="java之IO流">
      java之IO流 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JAVA数据结构与算法"><span class="nav-number">1.</span> <span class="nav-text">JAVA数据结构与算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-数据结构"><span class="nav-number">1.1.</span> <span class="nav-text">1 数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-线性结构"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1 线性结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-1-稀疏数组"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">1.1.1 稀疏数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-队列"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">1.1.2 队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-3-链表"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">1.1.3 链表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-3-1-单向链表"><span class="nav-number">1.1.1.3.1.</span> <span class="nav-text">1.1.3.1 单向链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-3-2-双向链表"><span class="nav-number">1.1.1.3.2.</span> <span class="nav-text">1.1.3.2 双向链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-3-3-循环链表"><span class="nav-number">1.1.1.3.3.</span> <span class="nav-text">1.1.3.3 循环链表</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-4-链表面试题"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">1.1.4 链表面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-4-1-求链表倒数第k个节点"><span class="nav-number">1.1.1.4.1.</span> <span class="nav-text">1.1.4.1 求链表倒数第k个节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-4-2-反转链表"><span class="nav-number">1.1.1.4.2.</span> <span class="nav-text">1.1.4.2 反转链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-4-3-逆序打印链表"><span class="nav-number">1.1.1.4.3.</span> <span class="nav-text">1.1.4.3 逆序打印链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-4-4-合并两个有序单链表"><span class="nav-number">1.1.1.4.4.</span> <span class="nav-text">1.1.4.4 合并两个有序单链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-4-5-约瑟夫环"><span class="nav-number">1.1.1.4.5.</span> <span class="nav-text">1.1.4.5 约瑟夫环</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-5-栈"><span class="nav-number">1.1.1.5.</span> <span class="nav-text">1.1.5 栈</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-5-1-栈实现综合计算器-中缀表达式"><span class="nav-number">1.1.1.5.1.</span> <span class="nav-text">1.1.5.1 栈实现综合计算器 (中缀表达式)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-5-2-计算器-前缀表达式"><span class="nav-number">1.1.1.5.2.</span> <span class="nav-text">1.1.5.2 计算器(前缀表达式)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-5-3-后缀表达式"><span class="nav-number">1.1.1.5.3.</span> <span class="nav-text">1.1.5.3  后缀表达式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-哈希表"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2 哈希表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-二叉树"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.3 二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-1-遍历"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">1.3.1 遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-2-查找"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">1.3.2 查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-3-删除"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">1.3.3 删除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-4-顺序二叉树"><span class="nav-number">1.1.3.4.</span> <span class="nav-text">1.3.4 顺序二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-5-线索化二叉树"><span class="nav-number">1.1.3.5.</span> <span class="nav-text">1.3.5 线索化二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-6-霍夫曼树"><span class="nav-number">1.1.3.6.</span> <span class="nav-text">1.3.6 霍夫曼树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-6-1-构建霍夫曼树"><span class="nav-number">1.1.3.6.1.</span> <span class="nav-text">1.3.6.1 构建霍夫曼树</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-7-二叉排序树"><span class="nav-number">1.1.3.7.</span> <span class="nav-text">1.3.7 二叉排序树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-7-1-删除节点"><span class="nav-number">1.1.3.7.1.</span> <span class="nav-text">1.3.7.1 删除节点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-8-平衡二叉树-AVL"><span class="nav-number">1.1.3.8.</span> <span class="nav-text">1.3.8 平衡二叉树(AVL)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-8-1-左旋"><span class="nav-number">1.1.3.8.1.</span> <span class="nav-text">1.3.8.1 左旋</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-8-2-右旋"><span class="nav-number">1.1.3.8.2.</span> <span class="nav-text">1.3.8.2 右旋</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-8-3-双旋"><span class="nav-number">1.1.3.8.3.</span> <span class="nav-text">1.3.8.3 双旋</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-多叉树"><span class="nav-number">1.1.4.</span> <span class="nav-text">1.4 多叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-1-2-3树"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">1.4.1 2-3树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-2-B树"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">1.4.2 B树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-图"><span class="nav-number">1.1.5.</span> <span class="nav-text">1.5 图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-1-深度优先搜索"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">1.5.1 深度优先搜索</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-2-广度优先搜索"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">1.5.2 广度优先搜索</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-算法"><span class="nav-number">1.2.</span> <span class="nav-text">2 算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-递归"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1 递归</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-迷宫问题"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">2.1.1 迷宫问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-八皇后问题"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">2.1.2 八皇后问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-排序"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2 排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-插入排序"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">2.2.1 插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-1-1-直接插入排序"><span class="nav-number">1.2.2.1.1.</span> <span class="nav-text">2.2.1.1 直接插入排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-1-2-希尔排序"><span class="nav-number">1.2.2.1.2.</span> <span class="nav-text">2.2.1.2 希尔排序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-选择排序"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">2.2.2 选择排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-2-1-简单选择排序"><span class="nav-number">1.2.2.2.1.</span> <span class="nav-text">2.2.2.1 简单选择排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-2-2-堆排序"><span class="nav-number">1.2.2.2.2.</span> <span class="nav-text">2.2.2.2 堆排序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-交换排序"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">2.2.3 交换排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-3-1-冒泡排序"><span class="nav-number">1.2.2.3.1.</span> <span class="nav-text">2.2.3.1 冒泡排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-3-2-快速排序"><span class="nav-number">1.2.2.3.2.</span> <span class="nav-text">2.2.3.2 快速排序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-4-归并排序"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">2.2.4 归并排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-5-基数排序"><span class="nav-number">1.2.2.5.</span> <span class="nav-text">2.2.5 基数排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-查找"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.3 查找</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-线性查找"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">2.3.1 线性查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-二分查找"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">2.3.2 二分查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3-插值查找"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">2.3.3 插值查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-4-斐波那契-黄金分割-查找"><span class="nav-number">1.2.3.4.</span> <span class="nav-text">2.3.4 斐波那契(黄金分割)查找</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-编码"><span class="nav-number">1.2.4.</span> <span class="nav-text">2.4 编码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-1-霍夫曼编码"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">2.4.1 霍夫曼编码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-分治法"><span class="nav-number">1.2.5.</span> <span class="nav-text">2.5 分治法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-1-汉诺塔"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">2.5.1 汉诺塔</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-动态规划"><span class="nav-number">1.2.6.</span> <span class="nav-text">2.6 动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-1-背包问题"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">2.6.1 背包问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-KMP"><span class="nav-number">1.2.7.</span> <span class="nav-text">2.7 KMP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-贪心算法"><span class="nav-number">1.2.8.</span> <span class="nav-text">2.8 贪心算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-8-1-集合覆盖问题"><span class="nav-number">1.2.8.1.</span> <span class="nav-text">2.8.1 集合覆盖问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-9-Prim算法"><span class="nav-number">1.2.9.</span> <span class="nav-text">2.9 Prim算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-0-Kruskal算法"><span class="nav-number">1.2.10.</span> <span class="nav-text">3.0 Kruskal算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-Dijkstra算法"><span class="nav-number">1.2.11.</span> <span class="nav-text">3.1 Dijkstra算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-Floyd算法"><span class="nav-number">1.2.12.</span> <span class="nav-text">3.2 Floyd算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-马踏棋盘问题"><span class="nav-number">1.2.13.</span> <span class="nav-text">3.3 马踏棋盘问题</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yong"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">yong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Herface" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Herface" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">He</span>
</div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>


        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

</body>
</html>
